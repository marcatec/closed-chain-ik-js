var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},e={},n={},o=t.parcelRequireafd0;null==o&&((o=function(t){if(t in e)return e[t].exports;if(t in n){var o=n[t];delete n[t];var s={id:t,exports:{}};return e[t]=s,o.call(s.exports,s,s.exports),s.exports}var r=new Error("Cannot find module '"+t+"'");throw r.code="MODULE_NOT_FOUND",r}).register=function(t,e){n[t]=e},t.parcelRequireafd0=o);var s=o("ilwiq"),r=o("5Rd1x"),i=o("fUhpq"),a=o("jiuw3"),c=o("7MGRS"),l=o("4CEV9"),d=o("8C12l"),u=o("7lx9d"),f=o("Q6arU");s=o("ilwiq");const p=new((s=o("ilwiq")).Vector3),h=new s.Vector3,y=new s.Vector3,w=new s.Vector2,g=new s.Vector2,m=new s.Vector2,x=new s.Vector3;function b(t,e,n,o,r,i,a){p.fromBufferAttribute(e,o),h.fromBufferAttribute(e,r),y.fromBufferAttribute(e,i);const c=function(t,e,n,o,r,i){let a;return a=i===s.BackSide?t.intersectTriangle(o,n,e,!0,r):t.intersectTriangle(e,n,o,i!==s.DoubleSide,r),null===a?null:{distance:t.origin.distanceTo(r),point:r.clone()}}(t,p,h,y,x,a);if(c){n&&(w.fromBufferAttribute(n,o),g.fromBufferAttribute(n,r),m.fromBufferAttribute(n,i),c.uv=s.Triangle.getUV(x,p,h,y,w,g,m,new s.Vector2));const t={a:o,b:r,c:i,normal:new s.Vector3,materialIndex:0};s.Triangle.getNormal(p,h,y,t.normal),c.face=t,c.faceIndex=o}return c}function T(t,e,n,o,s){const r=3*o,i=t.index.getX(r),a=t.index.getX(r+1),c=t.index.getX(r+2),l=b(n,t.attributes.position,t.attributes.uv,i,a,c,e);return l?(l.faceIndex=o,s&&s.push(l),l):null}function B(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t.distance<n.near||t.distance>n.far?null:t)}s=o("ilwiq");const P=Math.pow(2,-24);s=o("ilwiq");class M{constructor(){}}function S(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function A(t){let e=-1,n=-1/0;for(let o=0;o<3;o++){const s=t[o+3]-t[o];s>n&&(n=s,e=o)}return e}function v(t,e){e.set(t)}function V(t,e,n){let o,s;for(let r=0;r<3;r++){const i=r+3;o=t[r],s=e[r],n[r]=o<s?o:s,o=t[i],s=e[i],n[i]=o>s?o:s}}function F(t,e,n){for(let o=0;o<3;o++){const s=e[t+2*o],r=e[t+2*o+1],i=s-r,a=s+r;i<n[o]&&(n[o]=i),a>n[o+3]&&(n[o+3]=a)}}function E(t){const e=t[3]-t[0],n=t[4]-t[1],o=t[5]-t[2];return 2*(e*n+n*o+o*e)}function C(t,e,n,o,s=null){let r=1/0,i=1/0,a=1/0,c=-1/0,l=-1/0,d=-1/0,u=1/0,f=1/0,p=1/0,h=-1/0,y=-1/0,w=-1/0;const g=null!==s;for(let o=6*e,s=6*(e+n);o<s;o+=6){const e=t[o+0],n=t[o+1],s=e-n,m=e+n;s<r&&(r=s),m>c&&(c=m),g&&e<u&&(u=e),g&&e>h&&(h=e);const x=t[o+2],b=t[o+3],T=x-b,B=x+b;T<i&&(i=T),B>l&&(l=B),g&&x<f&&(f=x),g&&x>y&&(y=x);const P=t[o+4],M=t[o+5],S=P-M,A=P+M;S<a&&(a=S),A>d&&(d=A),g&&P<p&&(p=P),g&&P>w&&(w=P)}o[0]=r,o[1]=i,o[2]=a,o[3]=c,o[4]=l,o[5]=d,g&&(s[0]=u,s[1]=f,s[2]=p,s[3]=h,s[4]=y,s[5]=w)}const U=(t,e)=>t.candidate-e.candidate,I=new Array(32).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),D=new Float32Array(6);function R(t,e){function n(t){p&&p(t/h)}function o(e,s,r,p=null,h=0){if(!y&&h>=l&&(y=!0,d&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),r<=u||h>=l)return n(s+r),e.offset=s,e.count=r,e;const w=function(t,e,n,o,s,r){let i=-1,a=0;if(0===r)i=A(e),-1!==i&&(a=(e[i]+e[i+3])/2);else if(1===r)i=A(t),-1!==i&&(a=function(t,e,n,o){let s=0;for(let r=e,i=e+n;r<i;r++)s+=t[6*r+2*o];return s/n}(n,o,s,i));else if(2===r){const r=E(t);let c=1.25*s;const l=6*o,d=6*(o+s);for(let t=0;t<3;t++){const o=e[t],u=(e[t+3]-o)/32;if(s<8){const e=[...I];e.length=s;let o=0;for(let s=l;s<d;s+=6,o++){const r=e[o];r.candidate=n[s+2*t],r.count=0;const{bounds:i,leftCacheBounds:a,rightCacheBounds:c}=r;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0;F(s,n,i)}e.sort(U);let u=s;for(let t=0;t<u;t++){const n=e[t];for(;t+1<u&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),u--}for(let o=l;o<d;o+=6){const s=n[o+2*t];for(let t=0;t<u;t++){const r=e[t];s>=r.candidate?F(o,n,r.rightCacheBounds):(F(o,n,r.leftCacheBounds),r.count++)}}for(let n=0;n<u;n++){const o=e[n],l=o.count,d=s-o.count,u=o.leftCacheBounds,f=o.rightCacheBounds;let p=0;0!==l&&(p=E(u)/r);let h=0;0!==d&&(h=E(f)/r);const y=1+1.25*(p*l+h*d);y<c&&(i=t,c=y,a=o.candidate)}}else{for(let t=0;t<32;t++){const e=I[t];e.count=0,e.candidate=o+u+t*u;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=l;e<d;e+=6){let s=~~((n[e+2*t]-o)/u);s>=32&&(s=31);const r=I[s];r.count++,F(e,n,r.bounds)}const e=I[31];v(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=I[t],n=I[t+1];V(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let f=0;for(let e=0;e<31;e++){const n=I[e],o=n.count,l=n.bounds,d=I[e+1].rightCacheBounds;0!==o&&(0===f?v(l,D):V(l,D,D)),f+=o;let u=0,p=0;0!==f&&(u=E(D)/r);const h=s-f;0!==h&&(p=E(d)/r);const y=1+1.25*(u*f+p*h);y<c&&(i=t,c=y,a=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:i,pos:a}}(e.boundingData,p,a,s,r,f);if(-1===w.axis)return n(s+r),e.offset=s,e.count=r,e;const g=function(t,e,n,o,s){let r=n,i=n+o-1;const a=s.pos,c=2*s.axis;for(;;){for(;r<=i&&e[6*r+c]<a;)r++;for(;r<=i&&e[6*i+c]>=a;)i--;if(!(r<i))return r;for(let n=0;n<3;n++){let o=t[3*r+n];t[3*r+n]=t[3*i+n],t[3*i+n]=o;let s=e[6*r+2*n+0];e[6*r+2*n+0]=e[6*i+2*n+0],e[6*i+2*n+0]=s;let a=e[6*r+2*n+1];e[6*r+2*n+1]=e[6*i+2*n+1],e[6*i+2*n+1]=a}r++,i--}}(c,a,s,r,w);if(g===s||g===s+r)n(s+r),e.offset=s,e.count=r;else{e.splitAxis=w.axis;const t=new M,n=s,c=g-s;e.left=t,t.boundingData=new Float32Array(6),C(a,n,c,t.boundingData,i),o(t,n,c,i,h+1);const l=new M,d=g,u=r-c;e.right=l,l.boundingData=new Float32Array(6),C(a,d,u,l.boundingData,i),o(l,d,u,i,h+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let r;r=n>65535?new Uint32Array(new o(4*n)):new Uint16Array(new o(2*n)),t.setIndex(new s.BufferAttribute(r,1));for(let t=0;t<n;t++)r[t]=t}}(t,e);const r=new Float32Array(6),i=new Float32Array(6),a=function(t,e){const n=t.attributes.position,o=n.array,s=t.index.array,r=s.length/3,i=new Float32Array(6*r),a=n.offset||0;let c=3;n.isInterleavedBufferAttribute&&(c=n.data.stride);for(let t=0;t<r;t++){const n=3*t,r=6*t,l=s[n+0]*c+a,d=s[n+1]*c+a,u=s[n+2]*c+a;for(let t=0;t<3;t++){const n=o[l+t],s=o[d+t],a=o[u+t];let c=n;s<c&&(c=s),a<c&&(c=a);let f=n;s>f&&(f=s),a>f&&(f=a);const p=(f-c)/2,h=2*t;i[r+h+0]=c+p,i[r+h+1]=p+(Math.abs(c)+p)*P,c<e[t]&&(e[t]=c),f>e[t+3]&&(e[t+3]=f)}}return i}(t,r),c=t.index.array,l=e.maxDepth,d=e.verbose,u=e.maxLeafTris,f=e.strategy,p=e.onProgress,h=t.index.count/3;let y=!1;const w=[],g=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const o=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const n=o[t],s=o[t+1];e.push({offset:n/3,count:(s-n)/3})}return e}(t);if(1===g.length){const t=g[0],e=new M;e.boundingData=r,function(t,e,n,o){let s=1/0,r=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0;for(let o=6*e,d=6*(e+n);o<d;o+=6){const e=t[o+0];e<s&&(s=e),e>a&&(a=e);const n=t[o+2];n<r&&(r=n),n>c&&(c=n);const d=t[o+4];d<i&&(i=d),d>l&&(l=d)}o[0]=s,o[1]=r,o[2]=i,o[3]=a,o[4]=c,o[5]=l}(a,t.offset,t.count,i),o(e,t.offset,t.count,i),w.push(e)}else for(let t of g){const e=new M;e.boundingData=new Float32Array(6),C(a,t.offset,t.count,e.boundingData,i),o(e,t.offset,t.count,i),w.push(e)}return w}s=o("ilwiq"),s=o("ilwiq"),s=o("ilwiq");class L{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,o=-1/0;for(let s=0,r=t.length;s<r;s++){const r=t[s][e];n=r<n?r:n,o=r>o?r:o}this.min=n,this.max=o}setFromPoints(t,e){let n=1/0,o=-1/0;for(let s=0,r=e.length;s<r;s++){const r=e[s],i=t.dot(r);n=i<n?i:n,o=i>o?i:o}this.min=n,this.max=o}isSeparated(t){return this.min>t.max||t.min>this.max}}L.prototype.setFromBox=function(){const t=new s.Vector3;return function(e,n){const o=n.min,s=n.max;let r=1/0,i=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=o.x*n+s.x*(1-n),t.y=o.y*a+s.y*(1-a),t.z=o.z*c+s.z*(1-c);const l=e.dot(t);r=Math.min(l,r),i=Math.max(l,i)}this.min=r,this.max=i}}();!function(){const t=new L}();s=o("ilwiq"),s=o("ilwiq");const q=function(){const t=new s.Vector3,e=new s.Vector3,n=new s.Vector3;return function(o,s,r){const i=o.start,a=t,c=s.start,l=e;n.subVectors(i,c),t.subVectors(o.end,s.start),e.subVectors(s.end,s.start);const d=n.dot(l),u=l.dot(a),f=l.dot(l),p=n.dot(a),h=a.dot(a)*f-u*u;let y,w;y=0!==h?(d*u-p*f)/h:0,w=(d+y*u)/f,r.x=y,r.y=w}}(),_=function(){const t=new s.Vector2,e=new s.Vector3,n=new s.Vector3;return function(o,s,r,i){q(o,s,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return o.at(a,r),void s.at(c,i);if(a>=0&&a<=1)return c<0?s.at(0,i):s.at(1,i),void o.closestPointToPoint(i,!0,r);if(c>=0&&c<=1)return a<0?o.at(0,r):o.at(1,r),void s.closestPointToPoint(r,!0,i);{let t,l;t=a<0?o.start:o.end,l=c<0?s.start:s.end;const d=e,u=n;return o.closestPointToPoint(l,!0,e),s.closestPointToPoint(t,!0,n),d.distanceToSquared(l)<=u.distanceToSquared(t)?(r.copy(d),void i.copy(l)):(r.copy(t),void i.copy(u))}}}(),k=function(){const t=new s.Vector3,e=new s.Vector3,n=new s.Plane,o=new s.Line3;return function(s,r){const{radius:i,center:a}=s,{a:c,b:l,c:d}=r;o.start=c,o.end=l;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;o.start=c,o.end=d;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;o.start=l,o.end=d;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;const u=r.getPlane(n);if(Math.abs(u.distanceToPoint(a))<=i){const t=u.projectPoint(a,e);if(r.containsPoint(t))return!0}return!1}}();class O extends s.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new s.Vector3)),this.satBounds=new Array(4).fill().map((()=>new L)),this.points=[this.a,this.b,this.c],this.sphere=new s.Sphere,this.plane=new s.Plane,this.needsUpdate=!1}intersectsSphere(t){return k(t,this)}update(){const t=this.a,e=this.b,n=this.c,o=this.points,s=this.satAxes,r=this.satBounds,i=s[0],a=r[0];this.getNormal(i),a.setFromPoints(i,o);const c=s[1],l=r[1];c.subVectors(t,e),l.setFromPoints(c,o);const d=s[2],u=r[2];d.subVectors(e,n),u.setFromPoints(d,o);const f=s[3],p=r[3];f.subVectors(n,t),p.setFromPoints(f,o),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}O.prototype.closestPointToSegment=function(){const t=new s.Vector3,e=new s.Vector3,n=new s.Line3;return function(o,s=null,r=null){const{start:i,end:a}=o,c=this.points;let l,d=1/0;for(let i=0;i<3;i++){const a=(i+1)%3;n.start.copy(c[i]),n.end.copy(c[a]),_(n,o,t,e),l=t.distanceToSquared(e),l<d&&(d=l,s&&s.copy(t),r&&r.copy(e))}return this.closestPointToPoint(i,t),l=i.distanceToSquared(t),l<d&&(d=l,s&&s.copy(t),r&&r.copy(i)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<d&&(d=l,s&&s.copy(t),r&&r.copy(a)),Math.sqrt(d)}}(),O.prototype.intersectsTriangle=function(){const t=new O,e=new Array(3),n=new Array(3),o=new L,r=new L,i=new s.Vector3,a=new s.Vector3,c=new s.Vector3,l=new s.Vector3,d=new s.Line3,u=new s.Line3,f=new s.Line3;return function(s,p=null){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const h=this.plane,y=s.plane;if(Math.abs(h.normal.dot(y.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let e=0;e<4;e++){const s=t[e],r=a[e];if(o.setFromPoints(r,n),s.isSeparated(o))return!1}const c=s.satBounds,l=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=c[t],s=l[t];if(o.setFromPoints(s,e),n.isSeparated(o))return!1}for(let t=0;t<4;t++){const s=a[t];for(let t=0;t<4;t++){const a=l[t];if(i.crossVectors(s,a),o.setFromPoints(i,e),r.setFromPoints(i,n),o.isSeparated(r))return!1}}return p&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}{const t=this.points;let e=!1,n=0;for(let o=0;o<3;o++){const s=t[o],r=t[(o+1)%3];if(d.start.copy(s),d.end.copy(r),d.delta(a),0===y.normal.dot(a)&&0===y.distanceToPoint(d.start)){u.copy(d),n=2;break}if(y.intersectLine(d,e?u.start:u.end)){if(n++,e)break;e=!0}}if(2!==n)return!1;const o=s.points;let r=!1,i=0;for(let t=0;t<3;t++){const e=o[t],n=o[(t+1)%3];if(d.start.copy(e),d.end.copy(n),d.delta(c),0===h.normal.dot(c)&&0===h.distanceToPoint(d.start)){f.copy(d),i=2;break}if(h.intersectLine(d,r?f.start:f.end)){if(i++,r)break;r=!0}}if(2!==i)return!1;if(u.delta(a),f.delta(c),a.dot(c)<0){let t=f.start;f.start=f.end,f.end=t}const w=u.start.dot(a),g=u.end.dot(a),m=f.start.dot(a),x=f.end.dot(a),b=g<m,T=w<x;return(w===x||m===g||b!==T)&&(p&&(l.subVectors(u.start,f.start),l.dot(a)>0?p.start.copy(u.start):p.start.copy(f.start),l.subVectors(u.end,f.end),l.dot(a)<0?p.end.copy(u.end):p.end.copy(f.end)),!0)}}}(),O.prototype.distanceToPoint=function(){const t=new s.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),O.prototype.distanceToTriangle=function(){const t=new s.Vector3,e=new s.Vector3,n=["a","b","c"],o=new s.Line3,r=new s.Line3;return function(s,i=null,a=null){const c=i||a?o:null;if(this.intersectsTriangle(s,c))return(i||a)&&(i&&c.getCenter(i),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let o;const r=n[e],c=s[r];this.closestPointToPoint(c,t),o=c.distanceToSquared(t),o<l&&(l=o,i&&i.copy(t),a&&a.copy(c));const d=this[r];s.closestPointToPoint(d,t),o=d.distanceToSquared(t),o<l&&(l=o,i&&i.copy(d),a&&a.copy(t))}for(let c=0;c<3;c++){const d=n[c],u=n[(c+1)%3];o.set(this[d],this[u]);for(let c=0;c<3;c++){const d=n[c],u=n[(c+1)%3];r.set(s[d],s[u]),_(o,r,t,e);const f=t.distanceToSquared(e);f<l&&(l=f,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class N extends s.Box3{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new s.Matrix4,this.invMatrix=new s.Matrix4,this.points=new Array(8).fill().map((()=>new s.Vector3)),this.satAxes=new Array(3).fill().map((()=>new s.Vector3)),this.satBounds=new Array(3).fill().map((()=>new L)),this.alignedSatBounds=new Array(3).fill().map((()=>new L)),this.needsUpdate=!1}set(t,e,n){super.set(t,e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}function z(t,e,n,o){const s=t.a,r=t.b,i=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(e),c=n.getX(e+1),l=n.getX(e+2)),s.x=o.getX(a),s.y=o.getY(a),s.z=o.getZ(a),r.x=o.getX(c),r.y=o.getY(c),r.z=o.getZ(c),i.x=o.getX(l),i.y=o.getY(l),i.z=o.getZ(l)}function G(t,e,n,o,s,r,i){const a=n.index,c=n.attributes.position;for(let n=t,l=e+t;n<l;n++)if(z(i,3*n,a,c),i.needsUpdate=!0,o(i,n,s,r))return!0;return!1}N.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,o=this.points;for(let s=0;s<=1;s++)for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){const a=o[1*s|2*r|4*i];a.x=s?n.x:e.x,a.y=r?n.y:e.y,a.z=i?n.z:e.z,a.applyMatrix4(t)}const s=this.satBounds,r=this.satAxes,i=o[0];for(let t=0;t<3;t++){const e=r[t],n=s[t],a=o[1<<t];e.subVectors(i,a),n.setFromPoints(e,o)}const a=this.alignedSatBounds;a[0].setFromPointsField(o,"x"),a[1].setFromPointsField(o,"y"),a[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},N.prototype.intersectsBox=function(){const t=new L;return function(e){this.needsUpdate&&this.update();const n=e.min,o=e.max,s=this.satBounds,r=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=o.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=o.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=o.z,i[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const o=r[n],i=s[n];if(t.setFromBox(o,e),i.isSeparated(t))return!1}return!0}}(),N.prototype.intersectsTriangle=function(){const t=new O,e=new Array(3),n=new L,o=new L,r=new s.Vector3;return function(s){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const i=this.satBounds,a=this.satAxes;e[0]=s.a,e[1]=s.b,e[2]=s.c;for(let t=0;t<3;t++){const o=i[t],s=a[t];if(n.setFromPoints(s,e),o.isSeparated(n))return!1}const c=s.satBounds,l=s.satAxes,d=this.points;for(let t=0;t<3;t++){const e=c[t],o=l[t];if(n.setFromPoints(o,d),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const s=a[t];for(let t=0;t<4;t++){const i=l[t];if(r.crossVectors(s,i),n.setFromPoints(r,e),o.setFromPoints(r,d),n.isSeparated(o))return!1}}return!0}}(),N.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},N.prototype.distanceToPoint=function(){const t=new s.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),N.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new s.Line3)),n=new Array(12).fill().map((()=>new s.Line3)),o=new s.Vector3,r=new s.Vector3;return function(s,i=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(s))return(a||c)&&(s.getCenter(r),this.closestPointToPoint(r,o),s.closestPointToPoint(o,r),a&&a.copy(o),c&&c.copy(r)),0;const l=i*i,d=s.min,u=s.max,f=this.points;let p=1/0;for(let t=0;t<8;t++){const e=f[t];r.copy(e).clamp(d,u);const n=e.distanceToSquared(r);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(r),n<l))return Math.sqrt(n)}let h=0;for(let o=0;o<3;o++)for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){const i=(o+1)%3,a=(o+2)%3,c=1<<o|s<<i|r<<a,l=f[s<<i|r<<a],p=f[c];e[h].set(l,p);const y=t[o],w=t[i],g=t[a],m=n[h],x=m.start,b=m.end;x[y]=d[y],x[w]=s?d[w]:u[w],x[g]=r?d[g]:u[w],b[y]=u[y],b[w]=s?d[w]:u[w],b[g]=r?d[g]:u[w],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){r.x=t?u.x:d.x,r.y=e?u.y:d.y,r.z=n?u.z:d.z,this.closestPointToPoint(r,o);const s=r.distanceToSquared(o);if(s<p&&(p=s,a&&a.copy(o),c&&c.copy(r),s<l))return Math.sqrt(s)}for(let t=0;t<12;t++){const s=e[t];for(let t=0;t<12;t++){const e=n[t];_(s,e,o,r);const i=o.distanceToSquared(r);if(i<p&&(p=i,a&&a.copy(o),c&&c.copy(r),i<l))return Math.sqrt(i)}}return Math.sqrt(p)}}();class H{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function W(t,e){return 65535===e[t+15]}function J(t,e){return e[t+6]}function X(t,e){return e[t+14]}function j(t){return t+8}function Y(t,e){return e[t+6]}const Z=new s.Box3,K=new s.Vector3,$=["x","y","z"];function Q(t,e,n,o,s){let r=2*t,i=it,a=at,c=ct;if(W(r,a)){!function(t,e,n,o,s,r){for(let i=o,a=o+s;i<a;i++)T(t,e,n,i,r)}(e,n,o,J(t,c),X(r,a),s)}else{const r=j(t);ot(r,i,o,K)&&Q(r,e,n,o,s);const a=Y(t,c);ot(a,i,o,K)&&Q(a,e,n,o,s)}}function tt(t,e,n,o){let s=2*t,r=it,i=at,a=ct;if(W(s,i)){return function(t,e,n,o,s){let r=1/0,i=null;for(let a=o,c=o+s;a<c;a++){const o=T(t,e,n,a);o&&o.distance<r&&(i=o,r=o.distance)}return i}(e,n,o,J(t,a),X(s,i))}{const s=function(t,e){return e[t+7]}(t,a),i=$[s],c=o.direction[i]>=0;let l,d;c?(l=j(t),d=Y(t,a)):(l=Y(t,a),d=j(t));const u=ot(l,r,o,K)?tt(l,e,n,o):null;if(u){const t=u.point[i];if(c?t<=r[d+s]:t>=r[d+s+3])return u}const f=ot(d,r,o,K)?tt(d,e,n,o):null;return u&&f?u.distance<=f.distance?u:f:u||f||null}}const et=function(){let t,e;const n=[],o=new H((()=>new s.Box3));function r(n,o,s,i,a=null,c=0,l=0){function d(t){let e=2*t,n=at,o=ct;for(;!W(e,n);)e=2*(t=j(t));return J(t,o)}function u(t){let e=2*t,n=at,o=ct;for(;!W(e,n);)e=2*(t=Y(t,o));return J(t,o)+X(e,n)}let f=2*n,p=it,h=at,y=ct;if(W(f,h)){const e=J(n,y),o=X(f,h);return S(n,p,t),i(e,o,!1,l,c+n,t)}{const f=j(n),w=Y(n,y);let g,m,x,b,T=f,B=w;if(a&&(x=t,b=e,S(T,p,x),S(B,p,b),g=a(x),m=a(b),m<g)){T=w,B=f;const t=g;g=m,m=t,x=b}x||(x=t,S(T,p,x));const P=s(x,W(2*T,h),g,l+1,c+T);let M;if(2===P){const t=d(T);M=i(t,u(T)-t,!0,l+1,c+T,x)}else M=P&&r(T,o,s,i,a,c,l+1);if(M)return!0;b=e,S(B,p,b);const A=s(b,W(2*B,h),m,l+1,c+B);let v;if(2===A){const t=d(B);v=i(t,u(B)-t,!0,l+1,c+B,b)}else v=A&&r(B,o,s,i,a,c,l+1);return!!v}}return function(...s){t=o.getPrimitive(),e=o.getPrimitive(),n.push(t,e);const i=r(...s);o.releasePrimitive(t),o.releasePrimitive(e),n.pop(),n.pop();const a=n.length;return a>0&&(e=n[a-1],t=n[a-2]),i}}(),nt=function(){const t=new O,e=new O,n=new s.Matrix4,o=new N,r=new N;return function s(i,a,c,l,d=null){let u=2*i,f=it,p=at,h=ct;null===d&&(c.boundingBox||c.computeBoundingBox(),o.set(c.boundingBox.min,c.boundingBox.max,l),d=o);if(!W(u,p)){const t=i+8,e=h[i+6];S(t,f,Z);if(d.intersectsBox(Z)&&s(t,a,c,l,d))return!0;S(e,f,Z);return!!(d.intersectsBox(Z)&&s(e,a,c,l,d))}{const o=a,s=o.index,d=o.attributes.position,y=c.index,w=c.attributes.position,g=J(i,h),m=X(u,p);if(n.copy(l).invert(),c.boundsTree){S(i,f,r),r.matrix.copy(n),r.needsUpdate=!0;return c.boundsTree.shapecast({intersectsBounds:t=>r.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(l),t.b.applyMatrix4(l),t.c.applyMatrix4(l),t.needsUpdate=!0;for(let n=3*g,o=3*(m+g);n<o;n+=3)if(z(e,n,s,d),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}})}for(let o=3*g,r=m+3*g;o<r;o+=3){z(t,o,s,d),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,o=y.count;n<o;n+=3)if(z(e,n,y,w),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function ot(t,e,n,o){return S(t,e,Z),n.intersectBox(Z,o)}const st=[];let rt,it,at,ct;function lt(t){rt&&st.push(rt),rt=t,it=new Float32Array(t),at=new Uint16Array(t),ct=new Uint32Array(t)}function dt(){rt=null,it=null,at=null,ct=null,st.length&&lt(st.pop())}const ut=Symbol("skip tree generation"),ft=new s.Box3,pt=new s.Box3,ht=new s.Matrix4,yt=new N,wt=new N,gt=new s.Vector3,mt=new s.Vector3,xt=new s.Vector3,bt=new s.Vector3,Tt=new s.Vector3,Bt=new s.Box3,Pt=new H((()=>new O));class Mt{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Mt.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,o=t._roots,s=n.getIndex();let r;return r=e.cloneBuffers?{roots:o.map((t=>t.slice())),index:s.array.slice()}:{roots:o,index:s.array},r}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Mt.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:o,roots:r}=t,i=new Mt(e,{...n,[ut]:!0});if(i._roots=r,n.setIndex){const n=e.getIndex();if(null===n){const n=new s.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==o&&(n.array.set(o),n.needsUpdate=!0)}return i}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[ut]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[ut]||(this._roots=function(t,e){const n=R(t,e);let o,s,r;const i=[],a=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t],d=new a(32*c(e));o=new Float32Array(d),s=new Uint32Array(d),r=new Uint16Array(d),l(0,e),i.push(d)}function c(t){return t.count?1:1+c(t.left)+c(t.right)}function l(t,e){const n=t/4,i=t/2,a=!!e.count,c=e.boundingData;for(let t=0;t<6;t++)o[n+t]=c[t];if(a){const o=e.offset,a=e.count;return s[n+6]=o,r[i+14]=a,r[i+15]=65535,t+32}{const o=e.left,r=e.right,i=e.splitAxis;let a;if(a=l(t+32,o),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[n+6]=a/4,a=l(a,r),s[n+7]=i,a}}return i}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new s.Box3))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,o=e.attributes.position,s=o.array,r=o.offset||0;let i,a,c,l,d=3;o.isInterleavedBufferAttribute&&(d=o.data.stride);let u=0;const f=this._roots;for(let t=0,e=f.length;t<e;t++)i=f[t],a=new Uint32Array(i),c=new Uint16Array(i),l=new Float32Array(i),p(0,u),u+=i.byteLength;function p(e,o,i=!1){const u=2*e;if(65535===c[u+15]){const t=a[e+6];let o=1/0,i=1/0,f=1/0,p=-1/0,h=-1/0,y=-1/0;for(let e=3*t,a=3*(t+c[u+14]);e<a;e++){const t=n[e]*d+r,a=s[t+0],c=s[t+1],l=s[t+2];a<o&&(o=a),a>p&&(p=a),c<i&&(i=c),c>h&&(h=c),l<f&&(f=l),l>y&&(y=l)}return(l[e+0]!==o||l[e+1]!==i||l[e+2]!==f||l[e+3]!==p||l[e+4]!==h||l[e+5]!==y)&&(l[e+0]=o,l[e+1]=i,l[e+2]=f,l[e+3]=p,l[e+4]=h,l[e+5]=y,!0)}{const n=e+8,s=a[e+6],r=n+o,c=s+o;let d=i,u=!1,f=!1;t?d||(u=t.has(r),f=t.has(c),d=!u&&!f):(u=!0,f=!0);const h=d||f;let y=!1;(d||u)&&(y=p(n,o,d));let w=!1;h&&(w=p(s,o,d));const g=y||w;if(g)for(let t=0;t<3;t++){const o=n+t,r=s+t,i=l[o],a=l[o+3],c=l[r],d=l[r+3];l[e+t]=i<c?i:c,l[e+t+3]=a>d?a:d}return g}}}traverse(t,e=0){const n=this._roots[e],o=new Uint32Array(n),s=new Uint16Array(n);!function e(r,i=0){const a=2*r,c=65535===s[a+15];if(c){const e=o[r+6],l=s[a+14];t(i,c,new Float32Array(n,4*r,6),e,l)}else{const s=r+8,a=o[r+6],l=o[r+7];t(i,c,new Float32Array(n,4*r,6),l)||(e(s,i+1),e(a,i+1))}}(0)}raycast(t,e=s.FrontSide){const n=this._roots,o=this.geometry,r=[],i=e.isMaterial,a=Array.isArray(e),c=o.groups,l=i?e.side:e;for(let s=0,i=n.length;s<i;s++){const i=a?e[c[s].materialIndex].side:l,d=r.length;if(lt(n[s]),Q(0,o,i,t,r),dt(),a){const t=c[s].materialIndex;for(let e=d,n=r.length;e<n;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=s.FrontSide){const n=this._roots,o=this.geometry,r=e.isMaterial,i=Array.isArray(e);let a=null;const c=o.groups,l=r?e.side:e;for(let s=0,r=n.length;s<r;s++){const r=i?e[c[s].materialIndex].side:l;lt(n[s]);const d=tt(0,o,r,t);dt(),null!=d&&(null==a||d.distance<a.distance)&&(a=d,i&&(d.face.materialIndex=c[s].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let o=!1;for(const s of this._roots)if(lt(s),o=nt(0,n,t,e),dt(),o)break;return o}shapecast(t,e,n){const o=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,o,s)=>{const r=3*n;return t(e,r,r+1,r+2,o,s)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const s=Pt.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const t=a;a=(e,n,r,i,a)=>!!t(e,n,r,i,a)||G(e,n,o,c,r,i,s)}else a||(a=c?(t,e,n,r)=>G(t,e,o,c,n,r,s):(t,e,n)=>n);let l=!1,d=0;for(const t of this._roots){if(lt(t),l=et(0,o,i,a,r,d),dt(),l)break;d+=t.byteLength}return Pt.releasePrimitive(s),l}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:s}=n;const r=this.geometry.index,i=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;ht.copy(e).invert();const l=Pt.getPrimitive(),d=Pt.getPrimitive();if(s){function f(t,n,o,u,f,p,h,y){for(let w=o,g=o+u;w<g;w++){z(d,3*w,a,c),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let e=t,o=t+n;e<o;e++)if(z(l,3*e,r,i),l.needsUpdate=!0,s(l,d,e,w,f,p,h,y))return!0}return!1}if(o){const p=o;o=function(t,e,n,o,s,r,i,a){return!!p(t,e,n,o,s,r,i,a)||f(t,e,n,o,s,r,i,a)}}else o=f}this.getBoundingBox(pt),pt.applyMatrix4(e);const u=this.shapecast({intersectsBounds:t=>pt.intersectsBox(t),intersectsRange:(e,n,s,r,i,a)=>(ft.copy(a),ft.applyMatrix4(ht),t.shapecast({intersectsBounds:t=>ft.intersectsBox(t),intersectsRange:(t,s,a,c,l)=>o(e,n,t,s,r,i,c,l)}))});return Pt.releasePrimitive(l),Pt.releasePrimitive(d),u}intersectsBox(t,e){return yt.set(t.min,t.max,e),yt.needsUpdate=!0,this.shapecast({intersectsBounds:t=>yt.intersectsBox(t),intersectsTriangle:t=>yt.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},o={},s=0,r=1/0){t.boundingBox||t.computeBoundingBox(),yt.set(t.boundingBox.min,t.boundingBox.max,e),yt.needsUpdate=!0;const i=this.geometry,a=i.attributes.position,c=i.index,l=t.attributes.position,d=t.index,u=Pt.getPrimitive(),f=Pt.getPrimitive();let p=mt,h=xt,y=null,w=null;o&&(y=bt,w=Tt);let g=1/0,m=null,x=null;return ht.copy(e).invert(),wt.matrix.copy(ht),this.shapecast({boundsTraverseOrder:t=>yt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<r&&(e&&(wt.min.copy(t.min),wt.max.copy(t.max),wt.needsUpdate=!0),!0),intersectsRange:(n,o)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>wt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<r,intersectsRange:(t,r)=>{for(let i=3*t,b=3*(t+r);i<b;i+=3){z(f,i,d,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let t=3*n,e=3*(n+o);t<e;t+=3){z(u,t,c,a),u.needsUpdate=!0;const e=u.distanceToTriangle(f,p,y);if(e<g&&(h.copy(p),w&&w.copy(y),g=e,m=t/3,x=i/3),e<s)return!0}}}});for(let t=0,r=d?d.count:l.count;t<r;t+=3){z(f,t,d,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let e=3*n,r=3*(n+o);e<r;e+=3){z(u,e,c,a),u.needsUpdate=!0;const n=u.distanceToTriangle(f,p,y);if(n<g&&(h.copy(p),w&&w.copy(y),g=n,m=e/3,x=t/3),n<s)return!0}}}}),Pt.releasePrimitive(u),Pt.releasePrimitive(f),g===1/0?null:(n.point?n.point.copy(h):n.point=h.clone(),n.distance=g,n.faceIndex=m,o&&(o.point?o.point.copy(w):o.point=w.clone(),o.point.applyMatrix4(ht),h.applyMatrix4(ht),o.distance=h.sub(o.point).length(),o.faceIndex=x),n)}closestPointToPoint(t,e={},n=0,o=1/0){const s=n*n,r=o*o;let i=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(gt.copy(t).clamp(e.min,e.max),gt.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<i&&n<r,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,gt);const o=t.distanceToSquared(gt);return o<i&&(mt.copy(gt),i=o,a=n),o<s}}),i===1/0)return null;const c=Math.sqrt(i);return e.point?e.point.copy(mt):e.point=mt.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{S(0,new Float32Array(e),Bt),t.union(Bt)})),t}}const St=Mt.prototype.raycast;Mt.prototype.raycast=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[e,n,o,s]=t;return St.call(this,o,e.material).forEach((t=>{(t=B(t,e,n))&&s.push(t)})),s}return St.apply(this,t)};const At=Mt.prototype.raycastFirst;Mt.prototype.raycastFirst=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[e,n,o]=t;return B(At.call(this,o,e.material),e,n)}return At.apply(this,t)};const vt=Mt.prototype.closestPointToPoint;Mt.prototype.closestPointToPoint=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),t.unshift();const e=t[1],n={};return t[1]=n,vt.apply(this,t),e&&e.copy(n.point),n.distance}return vt.apply(this,t)};const Vt=Mt.prototype.closestPointToGeometry;Mt.prototype.closestPointToGeometry=function(...t){const e=t[2],n=t[3];if(e&&e.isVector3||n&&n.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const o={},s={},r=t[1];return t[2]=o,t[3]=s,Vt.apply(this,t),e&&e.copy(o.point),n&&n.copy(s.point).applyMatrix4(r),o.distance}return Vt.apply(this,t)};const Ft=Mt.prototype.refit;Mt.prototype.refit=function(...t){const e=t[0],n=t[1];if(n&&(n instanceof Set||Array.isArray(n))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const t=new Set;n.forEach((e=>t.add(e))),e&&e.forEach((e=>t.add(e))),Ft.call(this,t)}else Ft.apply(this,t)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach((t=>{const e=Mt.prototype[t];Mt.prototype[t]=function(...n){return(null===n[0]||n[0].isMesh)&&(n.shift(),console.warn(`MeshBVH: The function signature for "${t}" has changed and no longer takes Mesh. See docs for new signature.`)),e.apply(this,n)}}));const Et=new s.Ray,Ct=new s.Matrix4,Ut=s.Mesh.prototype.raycast;s.Mesh.prototype.raycast=function(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Ct.copy(this.matrixWorld).invert(),Et.copy(t.ray).applyMatrix4(Ct);const n=this.geometry.boundsTree;if(!0===t.firstHitOnly){const o=B(n.raycastFirst(Et,this.material),this,t);o&&e.push(o)}else{const o=n.raycast(Et,this.material);for(let n=0,s=o.length;n<s;n++){const s=B(o[n],this,t);s&&e.push(s)}}}else Ut.call(this,t,e)},s.BufferGeometry.prototype.computeBoundsTree=function(t){return this.boundsTree=new Mt(this,t),this.boundsTree},s.BufferGeometry.prototype.disposeBoundsTree=function(){this.boundsTree=null};const It={solve:!0,displayMesh:!0,displayIk:!1,enableControls:!0,terrainHeight:.35,settleIterations:10},Dt={maxIterations:10,divergeThreshold:.05,stallThreshold:1e-4,translationErrorClamp:1,rotationErrorClamp:.25};let Rt,Lt,qt,_t,kt,Ot,Nt,zt,Gt,Ht,Wt,Jt,Xt=!0;const jt=new s.Vector2,Yt=new s.Vector3,Zt=new s.Raycaster,Kt=new Float64Array(3);let $t,Qt,te,ee,ne;!function(){Lt=new c.default,document.body.appendChild(Lt.dom),qt=document.getElementById("output"),_t=new s.WebGLRenderer({antialias:!0}),_t.setPixelRatio(window.devicePixelRatio),_t.setSize(window.innerWidth,window.innerHeight),_t.shadowMap.enabled=!0,_t.shadowMap.type=s.PCFSoftShadowMap,_t.outputEncoding=s.sRGBEncoding,document.body.appendChild(_t.domElement),Ot=new s.PerspectiveCamera(50,window.innerWidth/window.innerHeight),Ot.position.set(8,8,8),kt=new s.Scene,kt.background=new s.Color(1971741),Jt=new s.DirectionalLight,Jt.position.set(1,3,2),Jt.intensity=.75,Jt.castShadow=!0,Jt.shadow.normalBias=1e-4,Jt.shadow.mapSize.setScalar(1024);const t=Jt.shadow.camera;t.top=t.right=2,t.left=t.bottom=-2,t.updateProjectionMatrix(),kt.add(Jt,Jt.target);const e=new s.AmbientLight(2038302,1);kt.add(e),zt=new r.OrbitControls(Ot,_t.domElement),Gt=new i.TransformControls(Ot,_t.domElement),Gt.setSpace("local"),kt.add(Gt),Gt.addEventListener("mouseDown",(()=>zt.enabled=!1)),Gt.addEventListener("mouseUp",(()=>zt.enabled=!0)),Ht=new s.Group,Ht.position.set(0,0,0),Ht.rotation.set(Math.PI/2,0,0),kt.add(Ht),Gt.attach(Ht),Gt.addEventListener("objectChange",(()=>{Xt=!0}));const n=400;Wt=new s.Mesh(new s.PlaneBufferGeometry(25,25,n,n),new s.MeshStandardMaterial);const o=Wt.geometry.attributes.position;for(let t=0;t<=401;t++)for(let e=0;e<=401;e++){const s=n*t+e,r=1.5*o.getX(s),i=1.5*o.getY(s);o.setZ(s,Math.min(Math.abs(Math.sin(i)),Math.abs(Math.sin(r))))}Wt.rotation.set(-Math.PI/2,0,0),Wt.geometry.computeVertexNormals(),Wt.receiveShadow=!0,Wt.geometry.computeBoundsTree(),kt.add(Wt),Rt=new a.GUI,Rt.add(It,"enableControls"),Rt.add(It,"solve"),Rt.add(It,"displayMesh"),Rt.add(It,"displayIk"),Rt.add(It,"settleIterations").min(1).max(20).step(1).onChange((()=>Xt=!0)),Rt.add(It,"terrainHeight",.05,.7).onChange((()=>Xt=!0));const p=new d.default;p.fetchOptions={mode:"cors"},p.loadMeshCb=(t,e,n)=>{/\.glb$/.test(t)||/\.gltf$/.test(t)?new u.GLTFLoader(e).load(t,(t=>{t.scene.traverse((t=>{t.castShadow=!0,t.receiveShadow=!0,t.geometry&&!t.geometry.attributes.normals&&t.geometry.computeVertexNormals()})),n(t.scene)})):/\.stl$/.test(t)&&new f.STLLoader(e).load(t,(t=>{const e=new s.Mesh(t);e.castShadow=!0,e.receiveShadow=!0,n(e)}))},p.loadAsync("https://raw.githubusercontent.com/gkjohnson/m2020-urdf-models/main/rover/m2020.urdf").then((t=>{t.traverse((t=>{"floating"===t.jointType&&(t.jointType="fixed")})),$t=t,Qt=l.urdfRobotToIKRoot($t,!0);const e=Qt.find((t=>"CENTER_DIFFERENTIAL"===t.name)).child;e.removeChild(e.children[0]);const n=Qt.find((t=>"LEFT_DIFFERENTIAL"===t.name)).child,o=new l.Joint;e.addChild(o);const r=new l.Link;r.setPosition(0,-.7,0),o.addChild(r);const i=new l.Joint;i.setDoF(l.DOF.EZ),r.addChild(i);const a=new l.Link;a.setPosition(0,0,0),i.addChild(a);const c=new l.Joint;c.setDoF(l.DOF.EY),a.addChild(c);const d=new l.Link;n.getWorldPosition(d.position),d.setMatrixNeedsUpdate(),c.attachChild(d),d.position[1]=0,d.position[2]=0,d.setMatrixNeedsUpdate();const u=new l.Joint;n.addChild(u);const f=new l.Link;d.getWorldPosition(f.position),d.getWorldQuaternion(f.quaternion),f.setMatrixNeedsUpdate(),u.attachChild(f);const p=new l.Goal;p.setFreeDoF(l.DOF.EX,l.DOF.EY,l.DOF.EZ),f.addChild(p),p.makeClosure(d);const h=Qt.find((t=>"RIGHT_DIFFERENTIAL"===t.name)).child,y=new l.Joint;e.addChild(y);const w=new l.Link;w.setPosition(0,.7,0),y.addChild(w);const g=new l.Joint;g.setDoF(l.DOF.EZ),w.addChild(g);const m=new l.Link;m.setPosition(0,0,0),g.addChild(m);const x=new l.Joint;x.setDoF(l.DOF.EY),m.addChild(x);const b=new l.Link;h.getWorldPosition(b.position),b.setMatrixNeedsUpdate(),x.attachChild(b),b.position[1]=0,b.position[2]=0,b.setMatrixNeedsUpdate();const T=new l.Joint;h.addChild(T);const B=new l.Link;b.getWorldPosition(B.position),b.getWorldQuaternion(B.quaternion),B.setMatrixNeedsUpdate(),T.attachChild(B);const P=new l.Goal;P.setFreeDoF(l.DOF.EX,l.DOF.EY,l.DOF.EZ),B.addChild(P),P.makeClosure(b),te=new l.IKRootsHelper([Qt]),te.setResolution(window.innerWidth,window.innerHeight),te.color.set(15277667).convertSRGBToLinear(),te.setColor(te.color),ee=new l.IKRootsHelper([Qt]),ee.setResolution(window.innerWidth,window.innerHeight),ee.color.set(15277667).convertSRGBToLinear(),ee.setColor(ee.color),ee.setDrawThrough(!0),$t.rotation.set(Math.PI/2,0,0),l.setIKFromUrdf(Qt,$t),Nt=["LR_DRIVE","LM_DRIVE","LF_DRIVE","RR_DRIVE","RM_DRIVE","RF_DRIVE"].map((t=>{const e=new l.Goal;return e.setGoalDoF(l.DOF.X,l.DOF.Y,l.DOF.Z),Qt.traverse((n=>{if(n.name===t){const t=n.child;t.getWorldPosition(e.position),e.setMatrixWorldNeedsUpdate(),e.makeClosure(t)}})),e})),Qt.traverse((t=>{switch(t.name){case"JOINT1_ENC":case"JOINT5_ENC":case"RSM_EL_ENC":t.setTargetValues(90*s.MathUtils.DEG2RAD),t.targetSet=!0;break;case"JOINT2_ENC":t.setTargetValues(-18*s.MathUtils.DEG2RAD),t.targetSet=!0;break;case"JOINT3_ENC":t.setTargetValues(-160*s.MathUtils.DEG2RAD),t.targetSet=!0;break;case"JOINT4_ENC":t.setTargetValues(178*s.MathUtils.DEG2RAD),t.targetSet=!0;break;case"RSM_AZ_ENC":t.setTargetValues(180*s.MathUtils.DEG2RAD),t.targetSet=!0}})),ne=new l.Solver([Qt,...Nt]),kt.add($t,te,ee)})),window.addEventListener("resize",(()=>{const t=window.innerWidth,e=window.innerHeight,n=t/e;_t.setSize(t,e),Ot.aspect=n,Ot.updateProjectionMatrix(),te&&(te.setResolution(window.innerWidth,window.innerHeight),ee.setResolution(window.innerWidth,window.innerHeight))})),window.addEventListener("keydown",(t=>{switch(t.key){case"w":Gt.setMode("translate");break;case"e":Gt.setMode("rotate");break;case"q":Gt.setSpace("local"===Gt.space?"world":"local");break;case"f":zt.target.set(0,0,0),zt.update()}})),_t.domElement.addEventListener("pointerdown",(t=>{jt.x=t.clientX,jt.y=t.clientY}))}(),function t(){requestAnimationFrame(t),Wt.scale.z=It.terrainHeight,$t&&(Xt&&It.solve?(!function(){Qt.setPosition(Ht.position.x,Qt.position[1],Ht.position.z),Qt.setQuaternion(Ht.quaternion.x,Ht.quaternion.y,Ht.quaternion.z,Ht.quaternion.w),Qt.traverse((t=>{t.isJoint&&(t.dofValues.fill(0),t.setMatrixDoFNeedsUpdate())}));let t="",e=0;for(let n=0;n<It.settleIterations;n++){Qt.updateMatrixWorld(!0),Nt.forEach(((t,e)=>{t.child.getWorldPosition(Kt),Zt.ray.origin.set(Kt[0],3,Kt[2]),Zt.ray.direction.set(0,-1,0),Zt.firstHitOnly=!0;let n=0;const o=Zt.intersectObject(Wt,!0);o.length&&(n=o[0].point.y+.25),t.setPosition(Kt[0],n,Kt[2])})),Object.assign(ne,Dt);const n=window.performance.now(),o=ne.solve(),s=window.performance.now()-n;e+=s,t+=s.toFixed(2)+"ms "+l.SOLVE_STATUS_NAMES[o[0]]+"\n";const r=o.filter((t=>t===l.SOLVE_STATUS.CONVERGED)).length===o.length,i=o.filter((t=>t===l.SOLVE_STATUS.DIVERGED)).length===o.length;if(r||i)break}t=t+"\nTotal: "+e.toFixed(2)+"ms",qt.textContent=t,l.setUrdfFromIK($t,Qt)}(),Xt=!1):It.solve||(Qt.setPosition(Ht.position.x,Ht.position.y,Ht.position.z),Qt.setQuaternion(Ht.quaternion.x,Ht.quaternion.y,Ht.quaternion.z,Ht.quaternion.w),l.setUrdfFromIK($t,Qt)));$t&&($t.visible=It.displayMesh,te.visible=It.displayIk,ee.visible=It.displayIk);Qt&&!Gt.dragging&&(Ht.position.set(...Qt.position),Ht.quaternion.set(...Qt.quaternion));$t&&(Yt.subVectors(Jt.position,Jt.target.position),Jt.target.position.copy($t.position),Jt.position.copy($t.position).add(Yt));Gt.visible=It.enableControls,Gt.enabled=It.enableControls,_t.render(kt,Ot),Lt.update()}();
//# sourceMappingURL=settling.efa3b5cd.js.map
