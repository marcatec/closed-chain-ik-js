{"mappings":"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","sources":["node_modules/three/examples/jsm/webxr/VRButton.js","node_modules/three/examples/jsm/libs/motion-controllers.module.js","node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js","example/lib/MaterialReducer.js","node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","example/lib/ProxyBatchedMesh.js","example/vr.js"],"sourcesContent":["class VRButton {\n\n\tstatic createButton( renderer, options ) {\n\n\t\tif ( options ) {\n\n\t\t\tconsole.error( 'THREE.VRButton: The \"options\" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.' );\n\n\t\t}\n\n\t\tconst button = document.createElement( 'button' );\n\n\t\tfunction showEnterVR( /*device*/ ) {\n\n\t\t\tlet currentSession = null;\n\n\t\t\tasync function onSessionStarted( session ) {\n\n\t\t\t\tsession.addEventListener( 'end', onSessionEnded );\n\n\t\t\t\tawait renderer.xr.setSession( session );\n\t\t\t\tbutton.textContent = 'EXIT VR';\n\n\t\t\t\tcurrentSession = session;\n\n\t\t\t}\n\n\t\t\tfunction onSessionEnded( /*event*/ ) {\n\n\t\t\t\tcurrentSession.removeEventListener( 'end', onSessionEnded );\n\n\t\t\t\tbutton.textContent = 'ENTER VR';\n\n\t\t\t\tcurrentSession = null;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tbutton.style.display = '';\n\n\t\t\tbutton.style.cursor = 'pointer';\n\t\t\tbutton.style.left = 'calc(50% - 50px)';\n\t\t\tbutton.style.width = '100px';\n\n\t\t\tbutton.textContent = 'ENTER VR';\n\n\t\t\tbutton.onmouseenter = function () {\n\n\t\t\t\tbutton.style.opacity = '1.0';\n\n\t\t\t};\n\n\t\t\tbutton.onmouseleave = function () {\n\n\t\t\t\tbutton.style.opacity = '0.5';\n\n\t\t\t};\n\n\t\t\tbutton.onclick = function () {\n\n\t\t\t\tif ( currentSession === null ) {\n\n\t\t\t\t\t// WebXR's requestReferenceSpace only works if the corresponding feature\n\t\t\t\t\t// was requested at session creation time. For simplicity, just ask for\n\t\t\t\t\t// the interesting ones as optional features, but be aware that the\n\t\t\t\t\t// requestReferenceSpace call will fail if it turns out to be unavailable.\n\t\t\t\t\t// ('local' is always available for immersive sessions and doesn't need to\n\t\t\t\t\t// be requested separately.)\n\n\t\t\t\t\tconst sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking', 'layers' ] };\n\t\t\t\t\tnavigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentSession.end();\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction disableButton() {\n\n\t\t\tbutton.style.display = '';\n\n\t\t\tbutton.style.cursor = 'auto';\n\t\t\tbutton.style.left = 'calc(50% - 75px)';\n\t\t\tbutton.style.width = '150px';\n\n\t\t\tbutton.onmouseenter = null;\n\t\t\tbutton.onmouseleave = null;\n\n\t\t\tbutton.onclick = null;\n\n\t\t}\n\n\t\tfunction showWebXRNotFound() {\n\n\t\t\tdisableButton();\n\n\t\t\tbutton.textContent = 'VR NOT SUPPORTED';\n\n\t\t}\n\n\t\tfunction showVRNotAllowed( exception ) {\n\n\t\t\tdisableButton();\n\n\t\t\tconsole.warn( 'Exception when trying to call xr.isSessionSupported', exception );\n\n\t\t\tbutton.textContent = 'VR NOT ALLOWED';\n\n\t\t}\n\n\t\tfunction stylizeElement( element ) {\n\n\t\t\telement.style.position = 'absolute';\n\t\t\telement.style.bottom = '20px';\n\t\t\telement.style.padding = '12px 6px';\n\t\t\telement.style.border = '1px solid #fff';\n\t\t\telement.style.borderRadius = '4px';\n\t\t\telement.style.background = 'rgba(0,0,0,0.1)';\n\t\t\telement.style.color = '#fff';\n\t\t\telement.style.font = 'normal 13px sans-serif';\n\t\t\telement.style.textAlign = 'center';\n\t\t\telement.style.opacity = '0.5';\n\t\t\telement.style.outline = 'none';\n\t\t\telement.style.zIndex = '999';\n\n\t\t}\n\n\t\tif ( 'xr' in navigator ) {\n\n\t\t\tbutton.id = 'VRButton';\n\t\t\tbutton.style.display = 'none';\n\n\t\t\tstylizeElement( button );\n\n\t\t\tnavigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) {\n\n\t\t\t\tsupported ? showEnterVR() : showWebXRNotFound();\n\n\t\t\t\tif ( supported && VRButton.xrSessionIsGranted ) {\n\n\t\t\t\t\tbutton.click();\n\n\t\t\t\t}\n\n\t\t\t} ).catch( showVRNotAllowed );\n\n\t\t\treturn button;\n\n\t\t} else {\n\n\t\t\tconst message = document.createElement( 'a' );\n\n\t\t\tif ( window.isSecureContext === false ) {\n\n\t\t\t\tmessage.href = document.location.href.replace( /^http:/, 'https:' );\n\t\t\t\tmessage.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n\n\t\t\t} else {\n\n\t\t\t\tmessage.href = 'https://immersiveweb.dev/';\n\t\t\t\tmessage.innerHTML = 'WEBXR NOT AVAILABLE';\n\n\t\t\t}\n\n\t\t\tmessage.style.left = 'calc(50% - 90px)';\n\t\t\tmessage.style.width = '180px';\n\t\t\tmessage.style.textDecoration = 'none';\n\n\t\t\tstylizeElement( message );\n\n\t\t\treturn message;\n\n\t\t}\n\n\t}\n\n\tstatic xrSessionIsGranted = false;\n\n\tstatic registerSessionGrantedListener() {\n\n\t\tif ( 'xr' in navigator ) {\n\n\t\t\tnavigator.xr.addEventListener( 'sessiongranted', () => {\n\n\t\t\t\tVRButton.xrSessionIsGranted = true;\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nVRButton.registerSessionGrantedListener();\n\nexport { VRButton };\n","/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\n\nconst Constants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n\n  ButtonTouchThreshold: 0.05,\n\n  AxisTouchThreshold: 0.1,\n\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  // Get the list of profiles\n  const supportedProfilesList = await fetchProfilesList(basePath);\n\n  // Find the relative path to the first requested profile that is recognized\n  let match;\n  xrInputSource.profiles.some((profileId) => {\n    const supportedProfile = supportedProfilesList[profileId];\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n\n  let assetPath;\n  if (getAssetPath) {\n    let layout;\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n    if (!layout) {\n      throw new Error(\n        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`\n      );\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return { profile, assetPath };\n}\n\n/** @constant {Object} */\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: Constants.ComponentState.DEFAULT\n};\n\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y;\n\n  // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n  const hypotenuse = Math.sqrt((x * x) + (y * y));\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  }\n\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n  const result = {\n    normalizedXAxis: (xAxis * 0.5) + 0.5,\n    normalizedYAxis: (yAxis * 0.5) + 0.5\n  };\n  return result;\n}\n\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    }\n\n    // Initializes the response's current value based on default data\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis, yAxis, button, state\n  }) {\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);\n    switch (this.componentProperty) {\n      case Constants.ComponentProperty.X_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedXAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.Y_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedYAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.BUTTON:\n        this.value = (this.states.includes(state)) ? button : 0;\n        break;\n      case Constants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {\n          this.value = (this.states.includes(state));\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n        break;\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n}\n\nclass Component {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    if (!componentId\n     || !componentDescription\n     || !componentDescription.visualResponses\n     || !componentDescription.gamepadIndices\n     || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName;\n\n    // Build all the visual responses for this component\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    });\n\n    // Set default values\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n\n    this.values = {\n      state: Constants.ComponentState.DEFAULT,\n      button: (this.gamepadIndices.button !== undefined) ? 0 : undefined,\n      xAxis: (this.gamepadIndices.xAxis !== undefined) ? 0 : undefined,\n      yAxis: (this.gamepadIndices.yAxis !== undefined) ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = { id: this.id, ...this.values };\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = Constants.ComponentState.DEFAULT;\n\n    // Get and normalize button\n    if (this.gamepadIndices.button !== undefined\n        && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = (this.values.button < 0) ? 0 : this.values.button;\n      this.values.button = (this.values.button > 1) ? 1 : this.values.button;\n\n      // Set the state based on the button\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = Constants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize x axis value\n    if (this.gamepadIndices.xAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = (this.values.xAxis < -1) ? -1 : this.values.xAxis;\n      this.values.xAxis = (this.values.xAxis > 1) ? 1 : this.values.xAxis;\n\n      // If the state is still default, check if the xAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize Y axis value\n    if (this.gamepadIndices.yAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = (this.values.yAxis < -1) ? -1 : this.values.yAxis;\n      this.values.yAxis = (this.values.yAxis > 1) ? 1 : this.values.yAxis;\n\n      // If the state is still default, check if the yAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Update the visual response weights based on the current component data\n    Object.values(this.visualResponses).forEach((visualResponse) => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n}\n\n/**\n  * @description Builds a motion controller with components and visual responses based on the\n  * supplied profile description. Data is polled from the xrInputSource's gamepad.\n  * @author Nell Waliczek / https://github.com/NellWaliczek\n*/\nclass MotionController {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId;\n\n    // Build child components as described in the profile description\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    });\n\n    // Initialize components based on current gamepad state\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach((component) => {\n      data.push(component.data);\n    });\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad() {\n    Object.values(this.components).forEach((component) => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n}\n\nexport { Constants, MotionController, fetchProfile, fetchProfilesList };\n","import {\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D,\n\tSphereGeometry,\n} from 'three';\n\nimport { GLTFLoader } from '../loaders/GLTFLoader.js';\n\nimport {\n\tConstants as MotionControllerConstants,\n\tfetchProfile,\n\tMotionController\n} from '../libs/motion-controllers.module.js';\n\nconst DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\nconst DEFAULT_PROFILE = 'generic-trigger';\n\nclass XRControllerModel extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\n\t}\n\n\tsetEnvironmentMap( envMap ) {\n\n\t\tif ( this.envMap == envMap ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.envMap = envMap;\n\t\tthis.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = this.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Polls data from the XRInputSource and updates the model's components to match\n\t * the real world data\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( ! this.motionController ) return;\n\n\t\t// Cause the MotionController to poll the Gamepad for data\n\t\tthis.motionController.updateFromGamepad();\n\n\t\t// Update the 3D model to reflect the button, thumbstick, and touchpad state\n\t\tObject.values( this.motionController.components ).forEach( ( component ) => {\n\n\t\t\t// Update node data based on the visual responses' current states\n\t\t\tObject.values( component.visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\t\tconst { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;\n\n\t\t\t\t// Skip if the visual response node is not found. No error is needed,\n\t\t\t\t// because it will have been reported at load time.\n\t\t\t\tif ( ! valueNode ) return;\n\n\t\t\t\t// Calculate the new properties based on the weight supplied\n\t\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY ) {\n\n\t\t\t\t\tvalueNode.visible = value;\n\n\t\t\t\t} else if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\t\tvalueNode.quaternion.slerpQuaternions(\n\t\t\t\t\t\tminNode.quaternion,\n\t\t\t\t\t\tmaxNode.quaternion,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t\tvalueNode.position.lerpVectors(\n\t\t\t\t\t\tminNode.position,\n\t\t\t\t\t\tmaxNode.position,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Walks the model's tree to find the nodes needed to animate the components and\n * saves them to the motionContoller components for use in the frame loop. When\n * touchpads are found, attaches a touch dot to them.\n */\nfunction findNodes( motionController, scene ) {\n\n\t// Loop through the components and find the nodes needed for each components' visual responses\n\tObject.values( motionController.components ).forEach( ( component ) => {\n\n\t\tconst { type, touchPointNodeName, visualResponses } = component;\n\n\t\tif ( type === MotionControllerConstants.ComponentType.TOUCHPAD ) {\n\n\t\t\tcomponent.touchPointNode = scene.getObjectByName( touchPointNodeName );\n\t\t\tif ( component.touchPointNode ) {\n\n\t\t\t\t// Attach a touch dot to the touchpad.\n\t\t\t\tconst sphereGeometry = new SphereGeometry( 0.001 );\n\t\t\t\tconst material = new MeshBasicMaterial( { color: 0x0000FF } );\n\t\t\t\tconst sphere = new Mesh( sphereGeometry, material );\n\t\t\t\tcomponent.touchPointNode.add( sphere );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( `Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Loop through all the visual responses to be applied to this component\n\t\tObject.values( visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\tconst { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;\n\n\t\t\t// If animating a transform, find the two nodes to be interpolated between.\n\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\tvisualResponse.minNode = scene.getObjectByName( minNodeName );\n\t\t\t\tvisualResponse.maxNode = scene.getObjectByName( maxNodeName );\n\n\t\t\t\t// If the extents cannot be found, skip this animation\n\t\t\t\tif ( ! visualResponse.minNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${minNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! visualResponse.maxNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${maxNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If the target node cannot be found, skip this animation\n\t\t\tvisualResponse.valueNode = scene.getObjectByName( valueNodeName );\n\t\t\tif ( ! visualResponse.valueNode ) {\n\n\t\t\t\tconsole.warn( `Could not find ${valueNodeName} in the model` );\n\n\t\t\t}\n\n\t\t} );\n\n\t} );\n\n}\n\nfunction addAssetSceneToControllerModel( controllerModel, scene ) {\n\n\t// Find the nodes needed for animation and cache them on the motionController.\n\tfindNodes( controllerModel.motionController, scene );\n\n\t// Apply any environment map that the mesh already has set.\n\tif ( controllerModel.envMap ) {\n\n\t\tscene.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = controllerModel.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Add the glTF scene to the controllerModel.\n\tcontrollerModel.add( scene );\n\n}\n\nclass XRControllerModelFactory {\n\n\tconstructor( gltfLoader = null ) {\n\n\t\tthis.gltfLoader = gltfLoader;\n\t\tthis.path = DEFAULT_PROFILES_PATH;\n\t\tthis._assetCache = {};\n\n\t\t// If a GLTFLoader wasn't supplied to the constructor create a new one.\n\t\tif ( ! this.gltfLoader ) {\n\n\t\t\tthis.gltfLoader = new GLTFLoader();\n\n\t\t}\n\n\t}\n\n\tcreateControllerModel( controller ) {\n\n\t\tconst controllerModel = new XRControllerModel();\n\t\tlet scene = null;\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad ) return;\n\n\t\t\tfetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {\n\n\t\t\t\tcontrollerModel.motionController = new MotionController(\n\t\t\t\t\txrInputSource,\n\t\t\t\t\tprofile,\n\t\t\t\t\tassetPath\n\t\t\t\t);\n\n\t\t\t\tconst cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];\n\t\t\t\tif ( cachedAsset ) {\n\n\t\t\t\t\tscene = cachedAsset.scene.clone();\n\n\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! this.gltfLoader ) {\n\n\t\t\t\t\t\tthrow new Error( 'GLTFLoader not set.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.gltfLoader.setPath( '' );\n\t\t\t\t\tthis.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {\n\n\t\t\t\t\t\tthis._assetCache[ controllerModel.motionController.assetUrl ] = asset;\n\n\t\t\t\t\t\tscene = asset.scene.clone();\n\n\t\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t\t},\n\t\t\t\t\tnull,\n\t\t\t\t\t() => {\n\n\t\t\t\t\t\tthrow new Error( `Asset ${controllerModel.motionController.assetUrl} missing or malformed.` );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} ).catch( ( err ) => {\n\n\t\t\t\tconsole.warn( err );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tcontrollerModel.motionController = null;\n\t\t\tcontrollerModel.remove( scene );\n\t\t\tscene = null;\n\n\t\t} );\n\n\t\treturn controllerModel;\n\n\t}\n\n}\n\nexport { XRControllerModelFactory };\n","/* eslint-disable */\n// https://github.com/gkjohnson/webxr-sandbox\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst textures = [];\n\t\tconst materials = [];\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t}\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3\n} from 'three';\n\n\nfunction computeTangents( geometry ) {\n\n\tgeometry.computeTangents();\n\tconsole.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.' );\n\n}\n\n/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\t// gather .userData\n\n\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst attrArrays = {};\n\tconst morphAttrsArrays = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t// initialize the arrays\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\n\t\tattrArrays[ name ] = [];\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the attribute arrays\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Generate typed arrays from new attribute arrays and update\n\t// the attributeBuffers\n\tconst result = geometry.clone();\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\tresult.setAttribute( name, attribute );\n\n\t\t// Update the attribute arrays\n\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tmaterial,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group, groupMaterial;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\n\n\nexport {\n\tcomputeTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n};\n","/* eslint-disable */\n// https://github.com/gkjohnson/webxr-sandbox\n\nimport {\n\tBone,\n\tSkinnedMesh,\n\tGroup,\n\tBufferAttribute,\n\tSkeleton,\n\tBox3,\n\tMatrix4,\n\tSphere,\n\tBufferGeometry,\n} from 'three';\nimport * as\tBufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\n\nconst inverseMatrix = new Matrix4();\nclass ProxySkinnedMesh extends SkinnedMesh {\n\n\tconstructor( geometry, material, meshes ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.proxied = meshes;\n\n\t}\n\n\traycast( ...args ) {\n\n\t\tconst { proxied } = this;\n\t\tfor ( let i = 0, l = proxied.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = proxied[ i ];\n\t\t\tmesh.raycast( ...args );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t\tconst { geometry, matrixWorld, proxied, frustumCulled } = this;\n\t\tif ( ! geometry.boundingBox ) {\n\n\t\t\tgeometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( ! geometry.boundingSphere ) {\n\n\t\t\tgeometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( frustumCulled ) {\n\n\t\t\tconst box = geometry.boundingBox;\n\t\t\tbox.makeEmpty();\n\n\t\t\tfor ( let i = 0, l = proxied.length; i < l; i ++ ) {\n\n\t\t\t\tbox.expandByObject( proxied[ i ] );\n\n\t\t\t}\n\n\t\t\tinverseMatrix.copy( matrixWorld ).invert();\n\t\t\tbox.applyMatrix4( inverseMatrix );\n\t\t\tbox.getBoundingSphere( geometry.boundingSphere );\n\n\t\t}\n\n\t}\n\n}\n\nclass ProxyBone extends Bone {\n\n\tconstructor( proxied ) {\n\n\t\tsuper();\n\t\tthis.proxied = proxied;\n\n\t}\n\n\tupdateMatrixWorld() {\n\n\t\tconst { matrixWorld, proxied } = this;\n\t\tproxied.updateMatrixWorld( true );\n\t\tmatrixWorld.copy( proxied.matrixWorld );\n\n\t}\n\n}\n\nexport class ProxyBatchedMesh extends Group {\n\n\tget visible() {\n\n\t\treturn this.proxied.visible;\n\n\t}\n\n\tset visible( v ) {\n\n\t\tif ( this.proxied ) {\n\n\t\t\tthis.proxied.visible = v;\n\n\t\t}\n\n\t}\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tif ( root.parent ) {\n\n\t\t\tthrow new Error( 'ProxyBatchedMesh : Proxied root is not expected to have a parent.' );\n\n\t\t}\n\n\t\t// Set it's parent to this so the matrix world computations\n\t\t// account for this transform.\n\t\troot.parent = this;\n\t\tthis.proxied = root;\n\n\t\t// Find all shared materials\n\t\tconst materialToGeometry = new Map();\n\t\troot.updateMatrixWorld( true );\n\t\troot.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tconst materials = c.material;\n\t\t\t\t\tconst hadIndex = Boolean( c.geometry.index );\n\t\t\t\t\tconst geometry = hadIndex ? c.geometry.clone().toNonIndexed() : c.geometry;\n\t\t\t\t\tconst groups = geometry.groups;\n\t\t\t\t\tconst attributes = geometry.attributes;\n\n\t\t\t\t\t// for every group create a trimmed geometry that includes only the relevant indices\n\t\t\t\t\tgroups.forEach( group => {\n\n\t\t\t\t\t\tconst material = materials[ group.materialIndex ];\n\t\t\t\t\t\tif ( ! materialToGeometry.get( material ) ) {\n\n\t\t\t\t\t\t\tmaterialToGeometry.set( material, [] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// create the trimmed attribute buffers\n\t\t\t\t\t\tconst trimmedGeometry = new BufferGeometry();\n\t\t\t\t\t\tfor ( const name in attributes ) {\n\n\t\t\t\t\t\t\tconst attribute = attributes[ name ];\n\t\t\t\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\t\t\t\tconst trimmedAttribute = new BufferAttribute(\n\t\t\t\t\t\t\t\tattribute.array.slice(\n\t\t\t\t\t\t\t\t\titemSize * group.start,\n\t\t\t\t\t\t\t\t\titemSize * ( group.start + group.count ),\n\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\tattribute.itemSize,\n\t\t\t\t\t\t\t\tattribute.normalized,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\ttrimmedGeometry.setAttribute( name, trimmedAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// create a new index array if it already had one\n\t\t\t\t\t\tif ( hadIndex ) {\n\n\t\t\t\t\t\t\tconst count = trimmedGeometry.attributes.position.count;\n\t\t\t\t\t\t\tconst indexArray = new Array( count )\n\t\t\t\t\t\t\t\t.fill()\n\t\t\t\t\t\t\t\t.map( ( value, index ) => index );\n\t\t\t\t\t\t\ttrimmedGeometry.setIndex( indexArray );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaterialToGeometry.get( material ).push( {\n\t\t\t\t\t\t\tmesh: c,\n\t\t\t\t\t\t\tgeometry: trimmedGeometry,\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst material = c.material;\n\t\t\t\t\tif ( ! materialToGeometry.get( material ) ) {\n\n\t\t\t\t\t\tmaterialToGeometry.set( material, [] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterialToGeometry.get( material ).push( {\n\t\t\t\t\t\tmesh: c,\n\t\t\t\t\t\tgeometry: c.geometry,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Merge all geometries with common materials into a single proxy skinned mesh\n\t\tmaterialToGeometry.forEach( ( infoArray, material ) => {\n\n\t\t\tconst weightCons = infoArray.length > 256 ? Uint16Array : Uint8Array;\n\t\t\tconst bones = [];\n\t\t\tconst geometries = infoArray.map( ( info, index ) => {\n\n\t\t\t\tconst originalGeometry = info.geometry;\n\t\t\t\tconst geometry = new BufferGeometry();\n\t\t\t\tfor ( const name in originalGeometry.attributes ) {\n\n\t\t\t\t\tgeometry.setAttribute( name, originalGeometry.getAttribute( name ) );\n\n\t\t\t\t}\n\t\t\t\tgeometry.setIndex( originalGeometry.getIndex() );\n\t\t\t\tconst count = geometry.attributes.position.count;\n\n\t\t\t\tconst weights = new Uint8Array( count * 4 );\n\t\t\t\tfor ( let i = 0, l = weights.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst i4 = i * 4;\n\t\t\t\t\tweights[ i4 ] = 255;\n\t\t\t\t\tweights[ i4 + 1 ] = 0;\n\t\t\t\t\tweights[ i4 + 2 ] = 0;\n\t\t\t\t\tweights[ i4 + 3 ] = 0;\n\n\t\t\t\t}\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'skinWeight',\n\t\t\t\t\tnew BufferAttribute( weights, 4, true ),\n\t\t\t\t);\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'skinIndex',\n\t\t\t\t\tnew BufferAttribute( new weightCons( count * 4 ).fill( index ), 4 ),\n\t\t\t\t);\n\n\t\t\t\tconst bone = new ProxyBone( info.mesh );\n\t\t\t\tbones.push( bone );\n\n\t\t\t\treturn geometry;\n\n\t\t\t} );\n\n\t\t\tconst skeleton = new Skeleton( bones );\n\t\t\tconst mergedGeometry = BufferGeometryUtils.mergeBufferGeometries( geometries );\n\n\t\t\tconst meshSet = new Set( infoArray.map( c => c.mesh ) );\n\t\t\tconst skinnedMesh = new ProxySkinnedMesh( mergedGeometry, material, Array.from( meshSet ) );\n\t\t\tskinnedMesh.bind( skeleton );\n\n\t\t\tskinnedMesh.add( ...bones );\n\t\t\tthis.add( skinnedMesh );\n\n\t\t} );\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst { proxied } = this;\n\t\tif ( proxied.parent && proxied.parent !== this ) {\n\n\t\t\tconsole.warn( 'ProxyBatchedMesh : Proxy mesh is expected to not have parent.' );\n\n\t\t}\n\n\t\tif ( proxied.parent === null ) {\n\n\t\t\tproxied.parent = this;\n\n\t\t}\n\t\tthis.updateWorldMatrix( false, false );\n\t\tproxied.updateMatrixWorld( ...args );\n\t\treturn super.updateMatrixWorld( ...args );\n\n\t}\n\n}\n","import {\n\tWebGLRenderer,\n\tPerspectiveCamera,\n\tColor,\n\tScene,\n\tDirectionalLight,\n\tAmbientLight,\n\tsRGBEncoding,\n\tGroup,\n\tRaycaster,\n\tVector4,\n\tMesh,\n\tSphereBufferGeometry,\n\tMeshBasicMaterial,\n\tTorusBufferGeometry,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tLineBasicMaterial,\n\tAdditiveBlending,\n\tLine,\n\tRingBufferGeometry,\n\tPCFSoftShadowMap,\n\tVector3,\n\tQuaternion,\n\tGridHelper,\n\tBox3,\n\tPlaneBufferGeometry,\n\tShadowMaterial,\n\tMeshPhongMaterial,\n\tBufferAttribute,\n} from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport {\n\tGUI,\n} from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { VRButton } from 'three/examples/jsm/webxr/VRButton.js';\nimport { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';\nimport { mat4 } from 'gl-matrix';\nimport {\n\tSolver,\n\tWorkerSolver,\n\tLink,\n\tJoint,\n\tIKRootsHelper,\n\tsetUrdfFromIK,\n} from '../src/index.js';\nimport {\n\tloadATHLETE,\n\tloadRobonaut,\n\tloadStaubli,\n\tloadCuriosity,\n} from './loadModels.js';\nimport {\n\tMaterialReducer\n} from './lib/MaterialReducer.js';\nimport {\n\tProxyBatchedMesh\n} from './lib/ProxyBatchedMesh.js';\n\nconst params = {\n\tshadows: true,\n\tliveRaycasting: true,\n\tscale: 1,\n\tsolve: true,\n\tdisplayIk: false,\n\tdisplayGoals: true,\n\tmodel: window.location.hash.replace( /^#/, '' ).trim() || 'ATHLETE',\n\twebworker: true,\n};\n\nconst solverOptions = {\n\tuseSVD: false,\n\tmaxIterations: 3,\n\tdivergeThreshold: 0.05,\n\tstallThreshold: 1e-4,\n\ttranslationErrorClamp: 0.25,\n\trotationErrorClamp: 0.25,\n\ttranslationConvergeThreshold: 1e-3,\n\trotationConvergeThreshold: 1e-5,\n\trestPoseFactor: 0.025,\n};\n\nconst goalToLinkMap = new Map();\nconst linkToGoalMap = new Map();\nconst goals = [];\nconst goalIcons = [];\nlet selectedGoalIndex = - 1;\n\nlet loadId = 0;\nlet gui;\nlet renderer, scene, camera, workspace, controller, controllerGrip, ground, directionalLight;\nlet intersectRing, hitSphere, targetObject;\nlet solver, ikHelper, drawThroughIkHelper, ikRoot, urdfRoot, urdfProxy;\nlet marsModel;\nconst tempPos = new Vector3();\nconst tempQuat = new Quaternion();\nconst raycaster = new Raycaster();\n\ninit();\nrebuildGUI();\nloadModelByName( params.model );\n\nfunction init() {\n\n\t// init renderer\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.shadowMap.enabled = true;\n\trenderer.shadowMap.type = PCFSoftShadowMap;\n\trenderer.outputEncoding = sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\tscene = new Scene();\n\tscene.background = new Color( 0x131619 );\n\n\tworkspace = new Group();\n\tworkspace.position.z = 3;\n\tscene.add( workspace );\n\n\tcamera = new PerspectiveCamera( 50, window.innerWidth / window.innerHeight );\n\tworkspace.add( camera );\n\n\tdirectionalLight = new DirectionalLight();\n\tdirectionalLight.position.set( 5, 30, 15 );\n\tdirectionalLight.castShadow = true;\n\tdirectionalLight.shadow.mapSize.set( 2048, 2048 );\n\tscene.add( directionalLight );\n\n\tconst ambientLight = new AmbientLight( 0x263238, 1 );\n\tscene.add( ambientLight );\n\n\tconst grid = new GridHelper( 10, 10, 0xffffff, 0xffffff );\n\tgrid.material.transparent = true;\n\tgrid.material.opacity = 0.1;\n\tgrid.material.depthWrite = false;\n\tscene.add( grid );\n\n\tground = new Mesh(\n\t\tnew PlaneBufferGeometry(),\n\t\tnew ShadowMaterial( {\n\n\t\t\tcolor: 0,\n\t\t\topacity: 0.25,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t} ),\n\t);\n\tground.receiveShadow = true;\n\tground.scale.setScalar( 30 );\n\tground.rotation.x = - Math.PI / 2;\n\tground.renderOrder = 1;\n\tscene.add( ground );\n\n\ttargetObject = new Group();\n\ttargetObject.position.set( 0, 1, 1 );\n\tscene.add( targetObject );\n\n\twindow.addEventListener( 'resize', onResize );\n\n\tmarsModel = new Group();\n\tmarsModel.rotation.set( 0, - Math.PI / 2, 0 );\n\tmarsModel.position.set( 0.5, 0, 2.35 );\n\tscene.add( marsModel );\n\n\tnew GLTFLoader().load( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/mars-site/scene.gltf', gltf => {\n\n\t\tconst marsScene = gltf.scene;\n\t\tmarsScene.scale.setScalar( 0.01 );\n\t\tmarsScene.updateMatrixWorld( true );\n\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( marsScene );\n\n\t\tmarsScene.position.y = - box.min.y;\n\n\t\tmarsModel.add( marsScene );\n\n\t} );\n\n\t// widgets\n\tconst whiteMat = new MeshBasicMaterial( { color: 0xffffff } );\n\tintersectRing = new Mesh( new TorusBufferGeometry( 0.25, 0.02, 16, 100 ), whiteMat );\n\tintersectRing.rotation.x = Math.PI / 2;\n\tintersectRing.visible = false;\n\tscene.add( intersectRing );\n\n\thitSphere = new Mesh( new SphereBufferGeometry( 0.005, 50, 50 ), whiteMat );\n\tscene.add( hitSphere );\n\n\t// vr\n\trenderer.xr.enabled = true;\n\trenderer.setAnimationLoop( render );\n\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t// vr controllers\n\tcontroller = renderer.xr.getController( 0 );\n\tcontroller.addEventListener( 'connected', function ( event ) {\n\n\t\tthis.add( buildController( event.data ) );\n\n\t} );\n\tcontroller.addEventListener( 'disconnected', function () {\n\n\t\tthis.remove( this.children[ 0 ] );\n\n\t} );\n\tworkspace.add( controller );\n\n\tconst startPos = new Vector3();\n\tconst endPos = new Vector3();\n\tlet startTime = - 1;\n\tcontroller.addEventListener( 'selectend', () => {\n\n\t\tif ( selectedGoalIndex !== - 1 ) {\n\n\t\t\tconst goal = goals[ selectedGoalIndex ];\n\t\t\tconst ikLink = goalToLinkMap.get( goal );\n\t\t\tif ( ikLink ) {\n\n\t\t\t\tikLink.updateMatrixWorld();\n\n\t\t\t\tikLink.attachChild( goal );\n\t\t\t\tgoal.setPosition( ...goal.originalPosition );\n\t\t\t\tgoal.setQuaternion( ...goal.originalQuaternion );\n\t\t\t\tikLink.detachChild( goal );\n\n\t\t\t\ttargetObject.position.set( ...goal.position );\n\t\t\t\ttargetObject.quaternion.set( ...goal.quaternion );\n\n\t\t\t}\n\n\t\t\tendPos.set( ...goal.position );\n\t\t\tif ( startPos.distanceTo( endPos ) < 1e-2 / params.scale && window.performance.now() - startTime < 500.0 ) {\n\n\t\t\t\tdeleteGoal( goal );\n\n\t\t\t}\n\n\t\t\tcontroller.remove( targetObject );\n\t\t\tselectedGoalIndex = - 1;\n\n\t\t}\n\n\t} );\n\n\tcontroller.addEventListener( 'selectstart', () => {\n\n\t\tif ( ! urdfRoot ) return;\n\n\t\tconst { ikLink, result } = raycast();\n\n\t\tstartPos.setScalar( Infinity );\n\t\tif ( ikLink === null ) {\n\n\t\t\tlet goalIndex = - 1;\n\t\t\tif ( result ) {\n\n\t\t\t\tgoalIndex = goalIcons.indexOf( result.object.parent );\n\n\t\t\t}\n\n\t\t\tselectedGoalIndex = goalIndex;\n\n\t\t\tif ( goalIndex !== - 1 ) {\n\n\t\t\t\tconst goal = goals[ goalIndex ];\n\t\t\t\ttargetObject.position.set( ...goal.position );\n\t\t\t\ttargetObject.quaternion.set( ...goal.quaternion );\n\t\t\t\tcontroller.attach( targetObject );\n\n\t\t\t\tstartPos.set( ...goal.position );\n\t\t\t\tstartTime = window.performance.now();\n\n\t\t\t} else if ( goalIndex === - 1 && intersectRing.visible ) {\n\n\t\t\t\tworkspace.position\n\t\t\t\t\t.copy( intersectRing.position )\n\t\t\t\t\t.addScaledVector( controller.position, - 1.0 / params.scale );\n\t\t\t\tworkspace.position.y = 0;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( linkToGoalMap.has( ikLink ) ) {\n\n\t\t\tconst goal = linkToGoalMap.get( ikLink );\n\t\t\tdeleteGoal( goal );\n\n\t\t}\n\n\t\t// normal in world space\n\t\tconst norm4 = new Vector4();\n\t\tnorm4.copy( result.face.normal );\n\t\tnorm4.w = 0;\n\t\tnorm4.applyMatrix4( result.object.matrixWorld );\n\n\t\t// create look matrix\n\t\tconst lookMat = mat4.create();\n\t\tconst eyeVec = [ 0, 0, 0 ];\n\t\tconst posVec = norm4.toArray();\n\t\tlet upVec = [ 0, 1, 0 ];\n\t\tif ( Math.abs( posVec[ 1 ] ) > 0.9 ) {\n\n\t\t\tupVec = [ 0, 0, 1 ];\n\n\t\t}\n\n\t\tmat4.targetTo( lookMat, eyeVec, posVec, upVec );\n\n\t\t// The joint that's positioned at the surface of the mesh\n\t\tconst rootGoalJoint = new Joint();\n\t\trootGoalJoint.name = 'GoalRootJoint-' + ikLink.name;\n\t\trootGoalJoint.setPosition(\n\t\t\tresult.point.x,\n\t\t\tresult.point.y,\n\t\t\tresult.point.z,\n\t\t);\n\t\tmat4.getRotation( rootGoalJoint.quaternion, lookMat );\n\n\t\tconst goalLink = new Link();\n\t\trootGoalJoint.addChild( goalLink );\n\n\t\tconst goalJoint = new Joint();\n\t\trootGoalJoint.name = 'GoalJoint-' + ikLink.name;\n\t\tikLink.getWorldPosition( goalJoint.position );\n\t\tikLink.getWorldQuaternion( goalJoint.quaternion );\n\t\tgoalJoint.setMatrixNeedsUpdate();\n\n\t\tgoalLink.attachChild( goalJoint );\n\t\tgoalJoint.makeClosure( ikLink );\n\n\t\t// save the relative position\n\t\tikLink.attachChild( rootGoalJoint );\n\t\trootGoalJoint.originalPosition = rootGoalJoint.position.slice();\n\t\trootGoalJoint.originalQuaternion = rootGoalJoint.quaternion.slice();\n\t\tikLink.detachChild( rootGoalJoint );\n\n\t\t// update the solver\n\t\tsolver.updateStructure();\n\t\tikHelper.updateStructure();\n\t\tdrawThroughIkHelper.updateStructure();\n\n\t\ttargetObject.position.set( ...rootGoalJoint.position );\n\t\ttargetObject.quaternion.set( ...rootGoalJoint.quaternion );\n\t\tcontroller.attach( targetObject );\n\n\t\tgoalToLinkMap.set( rootGoalJoint, ikLink );\n\t\tlinkToGoalMap.set( ikLink, rootGoalJoint );\n\t\tgoals.push( rootGoalJoint );\n\t\tselectedGoalIndex = goals.length - 1;\n\n\t} );\n\n\tconst controllerModelFactory = new XRControllerModelFactory();\n\tcontrollerGrip = renderer.xr.getControllerGrip( 0 );\n\tcontrollerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );\n\tworkspace.add( controllerGrip );\n\n}\n\nfunction deleteGoal( goal ) {\n\n\tconst index = goals.indexOf( goal );\n\tconst goalToRemove = goals[ index ];\n\tgoalToRemove.traverse( c => {\n\n\t\tif ( c.isClosure ) {\n\n\t\t\tc.removeChild( c.child );\n\n\t\t}\n\n\t} );\n\n\tgoals.splice( index, 1 );\n\n\tconst link = goalToLinkMap.get( goalToRemove );\n\tgoalToLinkMap.delete( goalToRemove );\n\tlinkToGoalMap.delete( link );\n\n\tsolver.updateStructure();\n\tikHelper.updateStructure();\n\tdrawThroughIkHelper.updateStructure();\n\n}\n\nfunction onResize() {\n\n\tconst w = window.innerWidth;\n\tconst h = window.innerHeight;\n\tconst aspect = w / h;\n\n\trenderer.setSize( w, h );\n\n\tcamera.aspect = aspect;\n\tcamera.updateProjectionMatrix();\n\n\tif ( ikHelper ) {\n\n\t\tikHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\tdrawThroughIkHelper.setResolution( window.innerWidth, window.innerHeight );\n\n\t}\n\n}\n\nfunction buildController( data ) {\n\n\tlet geometry, material;\n\n\tswitch ( data.targetRayMode ) {\n\n\t\tcase 'tracked-pointer':\n\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );\n\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );\n\n\t\t\tmaterial = new LineBasicMaterial( {\n\t\t\t\tvertexColors: true,\n\t\t\t\tblending: AdditiveBlending,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttransparent: true,\n\t\t\t} );\n\n\t\t\treturn new Line( geometry, material );\n\n\t\tcase 'gaze':\n\n\t\t\tgeometry = new RingBufferGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );\n\t\t\tmaterial = new MeshBasicMaterial( { opacity: 0.5, transparent: true } );\n\t\t\treturn new Mesh( geometry, material );\n\n\t}\n\n}\n\nfunction raycast( justGoals = false ) {\n\n\tcontroller.updateMatrixWorld();\n\traycaster.ray.origin.set( 0, 0, 0 ).applyMatrix4( controller.matrixWorld );\n\traycaster.ray.direction.set( 0, 0, - 1 ).transformDirection( controller.matrixWorld );\n\n\tlet results;\n\tconst intersectGoals = [ ...goalIcons ];\n\tintersectGoals.length = intersectGoals.length < goals.length ? intersectGoals.length : goals.length;\n\n\tresults = raycaster.intersectObjects( intersectGoals, true );\n\tif ( results.length !== 0 ) {\n\n\t\treturn { ikLink: null, result: results[ 0 ] };\n\n\t}\n\n\tif ( justGoals ) {\n\n\t\treturn { ikLink: null, result: null };\n\n\t}\n\n\tresults = raycaster.intersectObjects( [ urdfRoot ], true );\n\tif ( results.length === 0 ) {\n\n\t\treturn { ikLink: null, result: null };\n\n\t}\n\n\tconst result = results[ 0 ];\n\n\tlet nearestLink = null;\n\tlet ikLink = null;\n\tresult.object.traverseAncestors( p => {\n\n\t\tif ( nearestLink === null && p.isURDFLink ) {\n\n\t\t\tnearestLink = p;\n\t\t\tikRoot.traverse( c => {\n\n\t\t\t\tif ( c.name === nearestLink.name ) {\n\n\t\t\t\t\tikLink = c;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t} );\n\n\treturn { ikLink, result };\n\n}\n\nfunction render() {\n\n\tconst allGoals = goals;\n\tconst selectedGoal = allGoals[ selectedGoalIndex ];\n\tif ( ikRoot ) {\n\n\t\tintersectRing.visible = false;\n\t\thitSphere.visible = false;\n\t\tif ( selectedGoal ) {\n\n\t\t\ttargetObject.getWorldPosition( tempPos );\n\t\t\ttargetObject.getWorldQuaternion( tempQuat );\n\n\t\t\tselectedGoal.setPosition( tempPos.x, tempPos.y, tempPos.z );\n\t\t\tselectedGoal.setQuaternion( tempQuat.x, tempQuat.y, tempQuat.z, tempQuat.w );\n\n\t\t} else {\n\n\t\t\tconst { result } = raycast( ! params.liveRaycasting );\n\t\t\tconst lineRay = controller.children[ 0 ];\n\t\t\tif ( lineRay ) {\n\n\t\t\t\tlineRay.scale.setScalar( 1, 1, 1 );\n\n\t\t\t}\n\n\t\t\tif ( result === null ) {\n\n\t\t\t\traycaster.ray.origin.set( 0, 0, 0 ).applyMatrix4( controller.matrixWorld );\n\t\t\t\traycaster.ray.direction.set( 0, 0, - 1 ).transformDirection( controller.matrixWorld );\n\t\t\t\tconst hit = raycaster.intersectObject( ground )[ 0 ];\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersectRing.visible = true;\n\t\t\t\t\tintersectRing.position.copy( hit.point );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( lineRay ) {\n\n\t\t\t\t\tlineRay.scale.setScalar( result.distance * params.scale );\n\n\t\t\t\t}\n\n\t\t\t\thitSphere.position.copy( result.point );\n\t\t\t\thitSphere.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params.solve ) {\n\n\t\t\tif ( solver instanceof WorkerSolver ) {\n\n\t\t\t\tsolver.updateFrameState( ...allGoals );\n\t\t\t\tsolver.updateSolverSettings( solverOptions );\n\n\t\t\t\tif ( ! solver.running ) {\n\n\t\t\t\t\tsolver.solve();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tObject.assign( solver, solverOptions );\n\t\t\t\tsolver.solve();\n\n\t\t\t}\n\n\t\t\tsetUrdfFromIK( urdfRoot, ikRoot );\n\n\t\t}\n\n\t\t// IKHelpers can have a lot of matrices to update so remove it from\n\t\t// the scene when not in use for performance.\n\t\tif ( ! params.displayIk && ikHelper.parent ) {\n\n\t\t\tscene.remove( ikHelper );\n\t\t\tscene.remove( drawThroughIkHelper );\n\n\t\t} else if ( params.displayIk && ! ikHelper.parent ) {\n\n\t\t\tscene.add( ikHelper );\n\t\t\tscene.add( drawThroughIkHelper );\n\n\t\t}\n\n\t}\n\n\twhile ( goalIcons.length < allGoals.length ) {\n\n\t\tconst color = new Color( 0xffca28 ).convertSRGBToLinear();\n\t\tconst group = new Group();\n\t\tconst mesh = new Mesh(\n\t\t\tnew SphereBufferGeometry( 0.01, 30, 30 ),\n\t\t\tnew MeshBasicMaterial( { color } ),\n\t\t);\n\t\tconst mesh2 = new Mesh(\n\t\t\tnew SphereBufferGeometry( 0.01, 30, 30 ),\n\t\t\tnew MeshBasicMaterial( {\n\t\t\t\tcolor,\n\t\t\t\topacity: 0.4,\n\t\t\t\ttransparent: true,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false,\n\t\t\t} ),\n\t\t);\n\n\t\tgroup.add( mesh, mesh2 );\n\t\tscene.add( group );\n\t\tgoalIcons.push( group );\n\n\t}\n\n\tgoalIcons.forEach( g => {\n\n\t\tg.visible = false;\n\t\tg.scale.setScalar( 1 / params.scale );\n\n\t} );\n\tallGoals.forEach( ( g, i ) => {\n\n\t\tgoalIcons[ i ].position.set( ...g.position );\n\t\tgoalIcons[ i ].quaternion.set( ...g.quaternion );\n\t\tgoalIcons[ i ].visible = params.displayGoals;\n\n\t} );\n\n\tintersectRing.scale.setScalar( 1 / params.scale );\n\thitSphere.scale.setScalar( 1 / params.scale );\n\tworkspace.scale.setScalar( 1 / params.scale );\n\n\tdirectionalLight.castShadow = params.shadows;\n\trenderer.render( scene, camera );\n\n}\n\nfunction loadModelByName( name ) {\n\n\tlet promise = null;\n\tmarsModel.visible = false;\n\tswitch ( name ) {\n\n\t\tcase 'Robonaut':\n\t\t\tpromise = loadRobonaut();\n\t\t\tbreak;\n\n\t\tcase 'Curiosity':\n\t\t\tpromise = loadCuriosity();\n\t\t\tmarsModel.visible = true;\n\t\t\tbreak;\n\n\t\tcase 'Staubli':\n\t\t\tpromise = loadStaubli();\n\t\t\tbreak;\n\n\t\tcase 'ATHLETE':\n\t\tdefault:\n\t\t\tpromise = loadATHLETE();\n\t\t\tbreak;\n\n\t}\n\n\tloadModel( promise );\n\n}\n\nfunction rebuildGUI() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tif ( ! ikRoot ) return;\n\n\tgui = new GUI();\n\tgui.width = 350;\n\n\tgui.add( params, 'model', [ 'ATHLETE', 'Robonaut', 'Curiosity', 'Staubli' ] ).onChange( value => {\n\n\t\tloadModelByName( value );\n\n\t} );\n\tgui.add( params, 'scale', 0.1, 4, 0.01 );\n\tgui.add( params, 'shadows' );\n\tgui.add( params, 'liveRaycasting' );\n\tgui.add( params, 'displayGoals' ).name( 'display goals' );\n\tgui.add( params, 'displayIk' ).name( 'display ik chains' );\n\tgui.add( params, 'webworker' ).onChange( v => {\n\n\t\tif ( v ) {\n\n\t\t\tsolver = new WorkerSolver( solver.roots );\n\n\t\t} else {\n\n\t\t\tsolver.dispose();\n\t\t\tsolver = new Solver( solver.roots );\n\n\t\t}\n\n\t} );\n\tgui.add( { reset: () => {\n\n\t\tlet promise = null;\n\t\tswitch ( params.model ) {\n\n\t\t\tcase 'ATHLETE':\n\t\t\t\tpromise = loadATHLETE();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Robonaut':\n\t\t\t\tpromise = loadRobonaut();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Curiosity':\n\t\t\t\tpromise = loadCuriosity();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Staubli':\n\t\t\t\tpromise = loadStaubli();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tloadModel( promise );\n\n\t} }, 'reset' );\n\n\tconst solveFolder = gui.addFolder( 'solver' );\n\tsolveFolder.add( params, 'solve' ).onChange( v => {\n\n\t\tif ( ! v && solver instanceof WorkerSolver ) {\n\n\t\t\tsolver.stop();\n\n\t\t}\n\n\t} );\n\n\tsolveFolder.add( solverOptions, 'useSVD' );\n\tsolveFolder.add( solverOptions, 'maxIterations' ).min( 1 ).max( 10 ).step( 1 ).listen();\n\tsolveFolder.add( solverOptions, 'divergeThreshold' ).min( 0 ).max( 0.5 ).step( 1e-2 ).listen();\n\tsolveFolder.add( solverOptions, 'stallThreshold' ).min( 0 ).max( 0.01 ).step( 1e-4 ).listen();\n\tsolveFolder.add( solverOptions, 'translationErrorClamp' ).min( 1e-2 ).max( 1 ).listen();\n\tsolveFolder.add( solverOptions, 'rotationErrorClamp' ).min( 1e-2 ).max( 1 ).listen();\n\tsolveFolder.add( solverOptions, 'translationConvergeThreshold' ).min( 1e-3 ).max( 1e-1 ).listen();\n\tsolveFolder.add( solverOptions, 'rotationConvergeThreshold' ).min( 1e-5 ).max( 1e-2 ).listen();\n\tsolveFolder.add( solverOptions, 'restPoseFactor' ).min( 0 ).max( 0.25 ).step( 1e-2 ).listen();\n\tsolveFolder.open();\n\n}\n\nfunction dispose( c ) {\n\n\tif ( c.geometry ) {\n\n\t\tc.geometry.dispose();\n\n\t}\n\n\tif ( c.material ) {\n\n\t\tfunction disposeMaterial( material ) {\n\n\t\t\tmaterial.dispose();\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tif ( material[ key ] && material[ key ].isTexture ) {\n\n\t\t\t\t\tmaterial[ key ].dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\tc.material.forEach( disposeMaterial );\n\n\t\t} else {\n\n\t\t\tdisposeMaterial( c.material );\n\n\t\t}\n\n\n\t}\n\n}\n\nfunction loadModel( promise ) {\n\n\tif ( urdfRoot ) {\n\n\t\turdfRoot.traverse( dispose );\n\t\tdrawThroughIkHelper.traverse( dispose );\n\t\tikHelper.traverse( dispose );\n\t\turdfProxy.traverse( dispose );\n\n\t\tscene.remove( urdfRoot, drawThroughIkHelper, ikHelper, urdfProxy );\n\n\t}\n\n\tikRoot = null;\n\turdfRoot = null;\n\tikHelper = null;\n\tdrawThroughIkHelper = null;\n\tgoals.length = 0;\n\tgoalToLinkMap.clear();\n\tlinkToGoalMap.clear();\n\tselectedGoalIndex = - 1;\n\n\tloadId ++;\n\tconst thisLoadId = loadId;\n\tpromise\n\t\t.then( ( { goalMap, urdf, ik, helperScale = 1 } ) => {\n\n\t\t\tif ( loadId !== thisLoadId ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\turdf.traverse( c => {\n\n\t\t\t\tc.castShadow = true;\n\t\t\t\tc.receiveShadow = true;\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tfunction matToPhong( m ) {\n\n\t\t\t\t\t\treturn new MeshPhongMaterial( {\n\t\t\t\t\t\t\tmap: m.map,\n\t\t\t\t\t\t\tcolor: m.color,\n\t\t\t\t\t\t\tnormalMap: m.normalMap,\n\t\t\t\t\t\t\tnormalMapType: m.normalMapType,\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\t\tc.material = c.material.map( matToPhong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tc.material = matToPhong( c.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// remove redundant materials and textures\n\t\t\tconst reducer = new MaterialReducer();\n\t\t\treducer.process( urdf );\n\n\t\t\turdf.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tc.geometry.deleteAttribute( 'color' );\n\t\t\t\t\tif ( c.geometry.index ) {\n\n\t\t\t\t\t\tc.geometry.toNonIndexed();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( c.geometry.attributes.uv && ! c.material.map ) {\n\n\t\t\t\t\t\tc.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\t\t} else if ( ! c.geometry.attributes.uv && c.material.map ) {\n\n\t\t\t\t\t\tconst count = c.geometry.attributes.position.count;\n\t\t\t\t\t\tc.geometry.setAttribute(\n\t\t\t\t\t\t\t'uv',\n\t\t\t\t\t\t\tnew BufferAttribute(\n\t\t\t\t\t\t\t\tnew Float32Array( count * 2 ),\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\turdfProxy = new ProxyBatchedMesh( urdf );\n\t\t\turdfProxy.children.forEach( sm => {\n\n\t\t\t\tsm.castShadow = true;\n\t\t\t\tsm.receiveShadow = true;\n\t\t\t\tsm.material.skinning = true;\n\n\t\t\t} );\n\n\t\t\tsetUrdfFromIK( urdf, ik );\n\n\t\t\tconst box = new Box3();\n\t\t\turdf.updateMatrixWorld( true );\n\t\t\tbox.setFromObject( urdf );\n\t\t\turdf.position.y -= box.min.y;\n\t\t\tik.position[ 1 ] -= box.min.y;\n\t\t\tik.setMatrixNeedsUpdate();\n\n\n\t\t\tgoalMap.forEach( ( link, goal ) => {\n\n\t\t\t\tgoal.position[ 1 ] -= box.min.y;\n\t\t\t\tgoal.setMatrixNeedsUpdate();\n\n\t\t\t} );\n\n\t\t\tik.updateMatrixWorld( true );\n\n\t\t\t// create the helper\n\t\t\tikHelper = new IKRootsHelper( ik );\n\t\t\tikHelper.setJointScale( helperScale );\n\t\t\tikHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\t\tikHelper.color.set( 0xe91e63 ).convertSRGBToLinear();\n\t\t\tikHelper.setColor( ikHelper.color );\n\n\t\t\tdrawThroughIkHelper = new IKRootsHelper( ik );\n\t\t\tdrawThroughIkHelper.setJointScale( helperScale );\n\t\t\tdrawThroughIkHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\t\tdrawThroughIkHelper.color.set( 0xe91e63 ).convertSRGBToLinear();\n\t\t\tdrawThroughIkHelper.setColor( drawThroughIkHelper.color );\n\t\t\tdrawThroughIkHelper.setDrawThrough( true );\n\n\t\t\tscene.add( urdfProxy, ikHelper, drawThroughIkHelper );\n\n\t\t\tconst loadedGoals = [];\n\t\t\tgoalMap.forEach( ( link, goal ) => {\n\n\t\t\t\tloadedGoals.push( goal );\n\t\t\t\tgoalToLinkMap.set( goal, link );\n\t\t\t\tlinkToGoalMap.set( link, goal );\n\n\t\t\t} );\n\n\t\t\tsolver = params.webworker ? new WorkerSolver( ik ) : new Solver( ik );\n\n\t\t\tselectedGoalIndex = - 1;\n\n\t\t\tloadedGoals.forEach( g => {\n\n\t\t\t\tg.originalPosition = [ 0, 0, 0 ];\n\t\t\t\tg.originalQuaternion = [ 0, 0, 0, 1 ];\n\n\t\t\t} );\n\n\t\t\tikRoot = ik;\n\t\t\turdfRoot = urdf;\n\t\t\tgoals.push( ...loadedGoals );\n\n\t\t\trebuildGUI();\n\n\t\t} );\n\n}\n"],"names":["$2e81c5a0f10917ae$export$da3cdac99155b982","renderer","options","console","error","button","document","createElement","disableButton","style","display","cursor","left","width","onmouseenter","onmouseleave","onclick","stylizeElement","element","position","bottom","padding","border","borderRadius","background","color","font","textAlign","opacity","outline","zIndex","navigator","id","xr","isSessionSupported","then","supported","currentSession","onSessionStarted","session","addEventListener","onSessionEnded","setSession","textContent","removeEventListener","sessionInit","optionalFeatures","requestSession","end","showEnterVR","xrSessionIsGranted","click","catch","exception","warn","message","window","isSecureContext","href","location","replace","innerHTML","textDecoration","registerSessionGrantedListener","$7a8c3c23f3e49c64$export$a002182e51710d39","Handedness","Object","freeze","NONE","LEFT","RIGHT","ComponentState","DEFAULT","TOUCHED","PRESSED","ComponentProperty","BUTTON","X_AXIS","Y_AXIS","STATE","ComponentType","TRIGGER","SQUEEZE","TOUCHPAD","THUMBSTICK","ButtonTouchThreshold","AxisTouchThreshold","VisualResponseProperty","TRANSFORM","VISIBILITY","async","$7a8c3c23f3e49c64$var$fetchJsonFile","path","response","fetch","ok","json","Error","statusText","$7a8c3c23f3e49c64$export$665d336fd546fbed","xrInputSource","basePath","defaultProfile","getAssetPath","supportedProfilesList","$7a8c3c23f3e49c64$export$cdc669b4504544b3","match","profiles","some","profileId","supportedProfile","profilePath","deprecated","profile","assetPath","layout","handedness","layouts","keys","$7a8c3c23f3e49c64$var$defaultComponentValues","xAxis","yAxis","state","$7a8c3c23f3e49c64$var$VisualResponse","visualResponseDescription","this","componentProperty","states","valueNodeName","valueNodeProperty","minNodeName","maxNodeName","value","updateFromComponent","normalizedXAxis","normalizedYAxis","x","y","Math","sqrt","theta","atan2","cos","sin","$7a8c3c23f3e49c64$var$normalizeAxes","includes","$7a8c3c23f3e49c64$var$Component","constructor","componentId","componentDescription","visualResponses","gamepadIndices","length","type","rootNodeName","touchPointNodeName","forEach","responseName","visualResponse","assign","values","undefined","data","updateFromGamepad","gamepad","buttons","gamepadButton","pressed","touched","axes","abs","$7a8c3c23f3e49c64$export$d04f314260fc930a","assetUrl","layoutDescription","components","gripSpace","targetRaySpace","component","push","$e7e1ee5465c2c699$var$XRControllerModel","$ilwiq","Object3D","super","motionController","envMap","setEnvironmentMap","traverse","child","isMesh","material","needsUpdate","updateMatrixWorld","force","valueNode","minNode","maxNode","visible","quaternion","slerpQuaternions","lerpVectors","$e7e1ee5465c2c699$var$addAssetSceneToControllerModel","controllerModel","scene","touchPointNode","getObjectByName","sphereGeometry","SphereGeometry","MeshBasicMaterial","sphere","Mesh","add","$e7e1ee5465c2c699$var$findNodes","$e7e1ee5465c2c699$export$100331f925a5e0de","gltfLoader","_assetCache","$7lx9d","GLTFLoader","createControllerModel","controller","event","targetRayMode","cachedAsset","clone","setPath","load","asset","err","remove","$6f8ed3ce661202f2$var$isTypedArray","arr","buffer","ArrayBuffer","$6f8ed3ce661202f2$export$c80603c061964928","ignoreKeys","Set","shareTextures","areEqual","objectA","objectB","keySet","traverseSet","a","b","has","aIsElement","Element","bIsElement","Image","src","equals","aIsTypedArray","bIsTypedArray","i","l","clear","key","hasOwnProperty","Function","key1","Array","from","result","delete","process","object","textures","materials","replaced","processMaterial","foundMaterial","otherMaterial","isTexture","image","foundTexture","texture","c","isArray","retained","$5451ea62abbe5f68$export$c4eef4c1c9d34ea9","attributes","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","array","offset","i1","set","BufferAttribute","$c7e56af603358dd9$var$inverseMatrix","Matrix4","$c7e56af603358dd9$var$ProxySkinnedMesh","SkinnedMesh","geometry","meshes","proxied","raycast","args","matrixWorld","frustumCulled","boundingBox","Box3","boundingSphere","Sphere","box","makeEmpty","expandByObject","copy","invert","applyMatrix4","getBoundingSphere","$c7e56af603358dd9$var$ProxyBone","Bone","$c7e56af603358dd9$export$39dde25234c094a9","Group","v","root","parent","materialToGeometry","Map","hadIndex","Boolean","index","toNonIndexed","groups","group","materialIndex","get","trimmedGeometry","BufferGeometry","name","trimmedAttribute","slice","start","count","setAttribute","indexArray","fill","map","setIndex","mesh","infoArray","weightCons","Uint16Array","Uint8Array","bones","geometries","info","originalGeometry","getAttribute","getIndex","weights","i4","bone","skeleton","Skeleton","mergedGeometry","useGroups","isIndexed","attributesUsed","morphAttributesUsed","morphAttributes","morphTargetsRelative","attributesCount","size","name2","userData","mergedUserData","addGroup","indexOffset","mergedIndex","j","getX","mergedAttribute","name1","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","$5451ea62abbe5f68$export$728c051ccdf8a702","meshSet","skinnedMesh","bind","updateWorldMatrix","$ee960c3a73f75e07$var$params","shadows","liveRaycasting","scale","solve","displayIk","displayGoals","model","hash","trim","webworker","$ee960c3a73f75e07$var$solverOptions","useSVD","maxIterations","divergeThreshold","stallThreshold","translationErrorClamp","rotationErrorClamp","translationConvergeThreshold","rotationConvergeThreshold","restPoseFactor","$ee960c3a73f75e07$var$goalToLinkMap","$ee960c3a73f75e07$var$linkToGoalMap","$ee960c3a73f75e07$var$goals","$ee960c3a73f75e07$var$goalIcons","$ee960c3a73f75e07$var$gui","$ee960c3a73f75e07$var$renderer","$ee960c3a73f75e07$var$scene","$ee960c3a73f75e07$var$camera","$ee960c3a73f75e07$var$workspace","$ee960c3a73f75e07$var$controller","$ee960c3a73f75e07$var$controllerGrip","$ee960c3a73f75e07$var$ground","$ee960c3a73f75e07$var$directionalLight","$ee960c3a73f75e07$var$intersectRing","$ee960c3a73f75e07$var$hitSphere","$ee960c3a73f75e07$var$targetObject","$ee960c3a73f75e07$var$solver","$ee960c3a73f75e07$var$ikHelper","$ee960c3a73f75e07$var$drawThroughIkHelper","$ee960c3a73f75e07$var$ikRoot","$ee960c3a73f75e07$var$urdfRoot","$ee960c3a73f75e07$var$urdfProxy","$ee960c3a73f75e07$var$marsModel","$ee960c3a73f75e07$var$selectedGoalIndex","$ee960c3a73f75e07$var$loadId","$ee960c3a73f75e07$var$tempPos","Vector3","$ee960c3a73f75e07$var$tempQuat","Quaternion","$ee960c3a73f75e07$var$raycaster","Raycaster","$ee960c3a73f75e07$var$deleteGoal","goal","indexOf","goalToRemove","isClosure","removeChild","splice","link","updateStructure","$ee960c3a73f75e07$var$onResize","w","innerWidth","h","innerHeight","aspect","setSize","updateProjectionMatrix","setResolution","$ee960c3a73f75e07$var$raycast","justGoals","results","ray","origin","direction","transformDirection","intersectGoals","intersectObjects","ikLink","nearestLink","traverseAncestors","p","isURDFLink","$ee960c3a73f75e07$var$render","allGoals","selectedGoal","getWorldPosition","getWorldQuaternion","setPosition","z","setQuaternion","lineRay","children","setScalar","hit","intersectObject","point","distance","$4CEV9","WorkerSolver","updateFrameState","updateSolverSettings","running","setUrdfFromIK","Color","convertSRGBToLinear","SphereBufferGeometry","mesh2","transparent","depthWrite","depthTest","g","castShadow","render","$ee960c3a73f75e07$var$loadModelByName","promise","$7coGQ","loadRobonaut","loadCuriosity","loadStaubli","loadATHLETE","$ee960c3a73f75e07$var$loadModel","$ee960c3a73f75e07$var$rebuildGUI","destroy","$jiuw3","GUI","onChange","roots","dispose","Solver","reset","solveFolder","addFolder","stop","min","max","step","listen","open","$ee960c3a73f75e07$var$dispose","disposeMaterial","thisLoadId","goalMap","urdf","ik","helperScale","receiveShadow","matToPhong","m","MeshPhongMaterial","normalMap","normalMapType","deleteAttribute","uv","Float32Array","sm","skinning","setFromObject","setMatrixNeedsUpdate","IKRootsHelper","setJointScale","setColor","setDrawThrough","loadedGoals","originalPosition","originalQuaternion","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","shadowMap","enabled","PCFSoftShadowMap","outputEncoding","sRGBEncoding","body","appendChild","domElement","Scene","PerspectiveCamera","DirectionalLight","shadow","mapSize","ambientLight","AmbientLight","grid","GridHelper","PlaneBufferGeometry","ShadowMaterial","rotation","PI","renderOrder","gltf","marsScene","whiteMat","TorusBufferGeometry","setAnimationLoop","createButton","getController","Float32BufferAttribute","LineBasicMaterial","vertexColors","blending","AdditiveBlending","Line","RingBufferGeometry","translate","$ee960c3a73f75e07$var$buildController","startPos","endPos","startTime","attachChild","detachChild","distanceTo","performance","now","Infinity","goalIndex","attach","addScaledVector","norm4","Vector4","face","normal","lookMat","$6yEsn","mat4","create","posVec","toArray","upVec","targetTo","rootGoalJoint","Joint","getRotation","goalLink","Link","addChild","goalJoint","makeClosure","controllerModelFactory","getControllerGrip","$ee960c3a73f75e07$var$init"],"version":3,"file":"vr.747c8674.js.map"}