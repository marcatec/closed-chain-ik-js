{"mappings":"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","sources":["node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","node_modules/three-mesh-bvh/src/core/Constants.js","node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","node_modules/three-mesh-bvh/src/core/buildFunctions.js","node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","node_modules/three-mesh-bvh/src/math/MathUtilities.js","node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","node_modules/three-mesh-bvh/src/math/OrientedBox.js","node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js","node_modules/three-mesh-bvh/src/core/castFunctions.js","node_modules/three-mesh-bvh/src/core/MeshBVH.js","node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js","example/settling.js"],"sourcesContent":["import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\r\n\r\n// Ripped and modified From THREE.js Mesh raycast\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\r\nconst vA = /* @__PURE__ */ new Vector3();\r\nconst vB = /* @__PURE__ */ new Vector3();\r\nconst vC = /* @__PURE__ */ new Vector3();\r\n\r\nconst uvA = /* @__PURE__ */ new Vector2();\r\nconst uvB = /* @__PURE__ */ new Vector2();\r\nconst uvC = /* @__PURE__ */ new Vector2();\r\n\r\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\r\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\r\n\r\n\tlet intersect;\r\n\tif ( side === BackSide ) {\r\n\r\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t} else {\r\n\r\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\r\n\r\n\t}\r\n\r\n\tif ( intersect === null ) return null;\r\n\r\n\tconst distance = ray.origin.distanceTo( point );\r\n\r\n\treturn {\r\n\r\n\t\tdistance: distance,\r\n\t\tpoint: point.clone(),\r\n\r\n\t};\r\n\r\n}\r\n\r\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\r\n\r\n\tvA.fromBufferAttribute( position, a );\r\n\tvB.fromBufferAttribute( position, b );\r\n\tvC.fromBufferAttribute( position, c );\r\n\r\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tif ( uv ) {\r\n\r\n\t\t\tuvA.fromBufferAttribute( uv, a );\r\n\t\t\tuvB.fromBufferAttribute( uv, b );\r\n\t\t\tuvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst face = {\r\n\t\t\ta: a,\r\n\t\t\tb: b,\r\n\t\t\tc: c,\r\n\t\t\tnormal: new Vector3(),\r\n\t\t\tmaterialIndex: 0\r\n\t\t};\r\n\r\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\r\n\r\n\t\tintersection.face = face;\r\n\t\tintersection.faceIndex = a;\r\n\r\n\t}\r\n\r\n\treturn intersection;\r\n\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\r\nfunction intersectTri( geo, side, ray, tri, intersections ) {\r\n\r\n\tconst triOffset = tri * 3;\r\n\tconst a = geo.index.getX( triOffset );\r\n\tconst b = geo.index.getX( triOffset + 1 );\r\n\tconst c = geo.index.getX( triOffset + 2 );\r\n\r\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tintersection.faceIndex = tri;\r\n\t\tif ( intersections ) intersections.push( intersection );\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\nexport { intersectTri };\r\n","import { intersectTri } from './ThreeRayIntersectUtilities.js';\r\n\r\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\r\n\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tintersectTri( geo, side, ray, i, intersections );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\r\n\r\n\tlet dist = Infinity;\r\n\tlet res = null;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tconst intersection = intersectTri( geo, side, ray, i );\r\n\t\tif ( intersection && intersection.distance < dist ) {\r\n\r\n\t\t\tres = intersection;\r\n\t\t\tdist = intersection.distance;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\n// converts the given BVH raycast intersection to align with the three.js raycast\r\n// structure (include object, world space distance and point).\r\nexport function convertRaycastIntersect( hit, object, raycaster ) {\r\n\r\n\tif ( hit === null ) {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\thit.point.applyMatrix4( object.matrixWorld );\r\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\r\n\thit.object = object;\r\n\r\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\r\n\r\n\t\treturn null;\r\n\r\n\t} else {\r\n\r\n\t\treturn hit;\r\n\r\n\t}\r\n\r\n}\r\n","// Split strategy constants\r\nexport const CENTER = 0;\r\nexport const AVERAGE = 1;\r\nexport const SAH = 2;\r\n\r\n// Traversal constants\r\nexport const NOT_INTERSECTED = 0;\r\nexport const INTERSECTED = 1;\r\nexport const CONTAINED = 2;\r\n\r\n// SAH cost constants\r\n// TODO: hone these costs more. The relative difference between them should be the\r\n// difference in measured time to perform a triangle intersection vs traversing\r\n// bounds.\r\nexport const TRIANGLE_INTERSECT_COST = 1.25;\r\nexport const TRAVERSAL_COST = 1;\r\n\r\n\r\n// Build constants\r\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\r\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\r\n\r\n// EPSILON for computing floating point error during build\r\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\r\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\r\n\r\n","export class MeshBVHNode {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// internal nodes have boundingData, left, right, and splitAxis\r\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\r\n\r\n\t}\r\n\r\n}\r\n","export function arrayToBox( nodeIndex32, array, target ) {\r\n\r\n\ttarget.min.x = array[ nodeIndex32 ];\r\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\r\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\r\n\r\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\r\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\r\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nexport function getLongestEdgeIndex( bounds ) {\r\n\r\n\tlet splitDimIdx = - 1;\r\n\tlet splitDist = - Infinity;\r\n\r\n\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\r\n\t\tif ( dist > splitDist ) {\r\n\r\n\t\t\tsplitDist = dist;\r\n\t\t\tsplitDimIdx = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitDimIdx;\r\n\r\n}\r\n\r\n// copys bounds a into bounds b\r\nexport function copyBounds( source, target ) {\r\n\r\n\ttarget.set( source );\r\n\r\n}\r\n\r\n// sets bounds target to the union of bounds a and b\r\nexport function unionBounds( a, b, target ) {\r\n\r\n\tlet aVal, bVal;\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst d3 = d + 3;\r\n\r\n\t\t// set the minimum values\r\n\t\taVal = a[ d ];\r\n\t\tbVal = b[ d ];\r\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\r\n\r\n\t\t// set the max values\r\n\t\taVal = a[ d3 ];\r\n\t\tbVal = b[ d3 ];\r\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// expands the given bounds by the provided triangle bounds\r\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\r\n\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\r\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\r\n\r\n\t\tconst tMin = tCenter - tHalf;\r\n\t\tconst tMax = tCenter + tHalf;\r\n\r\n\t\tif ( tMin < bounds[ d ] ) {\r\n\r\n\t\t\tbounds[ d ] = tMin;\r\n\r\n\t\t}\r\n\r\n\t\tif ( tMax > bounds[ d + 3 ] ) {\r\n\r\n\t\t\tbounds[ d + 3 ] = tMax;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// compute bounds surface area\r\nexport function computeSurfaceArea( bounds ) {\r\n\r\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\r\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\r\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\r\n\r\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\r\n\r\n}\r\n","import { BufferAttribute } from 'three';\r\nimport { MeshBVHNode } from './MeshBVHNode.js';\r\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\r\nimport {\r\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\r\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\r\n} from './Constants.js';\r\n\r\nfunction ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tlet index;\r\n\t\tif ( vertexCount > 65535 ) {\r\n\r\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t\t}\r\n\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n// region in the geometry index that belongs to a different set of material groups requires\r\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n// with triangle indices belongs to another group. For example, if the groups were like this:\r\n//\r\n// [-------------------------------------------------------------]\r\n// |__________________|\r\n//   g0 = [0, 20]  |______________________||_____________________|\r\n//                      g1 = [16, 40]           g2 = [41, 60]\r\n//\r\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\nfunction getRootIndexRanges( geo ) {\r\n\r\n\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\r\n\r\n\t}\r\n\r\n\tconst ranges = [];\r\n\tconst rangeBoundaries = new Set();\r\n\tfor ( const group of geo.groups ) {\r\n\r\n\t\trangeBoundaries.add( group.start );\r\n\t\trangeBoundaries.add( group.start + group.count );\r\n\r\n\t}\r\n\r\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\r\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\r\n\r\n\t}\r\n\r\n\treturn ranges;\r\n\r\n}\r\n\r\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\r\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\r\n// These are computed together to avoid redundant accesses to bounds array.\r\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\r\n\r\n\tlet minx = Infinity;\r\n\tlet miny = Infinity;\r\n\tlet minz = Infinity;\r\n\tlet maxx = - Infinity;\r\n\tlet maxy = - Infinity;\r\n\tlet maxz = - Infinity;\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tconst includeCentroid = centroidTarget !== null;\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tconst hx = triangleBounds[ i + 1 ];\r\n\t\tconst lx = cx - hx;\r\n\t\tconst rx = cx + hx;\r\n\t\tif ( lx < minx ) minx = lx;\r\n\t\tif ( rx > maxx ) maxx = rx;\r\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\r\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tconst hy = triangleBounds[ i + 3 ];\r\n\t\tconst ly = cy - hy;\r\n\t\tconst ry = cy + hy;\r\n\t\tif ( ly < miny ) miny = ly;\r\n\t\tif ( ry > maxy ) maxy = ry;\r\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\r\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tconst hz = triangleBounds[ i + 5 ];\r\n\t\tconst lz = cz - hz;\r\n\t\tconst rz = cz + hz;\r\n\t\tif ( lz < minz ) minz = lz;\r\n\t\tif ( rz > maxz ) maxz = rz;\r\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\r\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\ttarget[ 0 ] = minx;\r\n\ttarget[ 1 ] = miny;\r\n\ttarget[ 2 ] = minz;\r\n\r\n\ttarget[ 3 ] = maxx;\r\n\ttarget[ 4 ] = maxy;\r\n\ttarget[ 5 ] = maxz;\r\n\r\n\tif ( includeCentroid ) {\r\n\r\n\t\tcentroidTarget[ 0 ] = cminx;\r\n\t\tcentroidTarget[ 1 ] = cminy;\r\n\t\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\t\tcentroidTarget[ 3 ] = cmaxx;\r\n\t\tcentroidTarget[ 4 ] = cmaxy;\r\n\t\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A stand alone function for retrieving the centroid bounds.\r\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tif ( cx < cminx ) cminx = cx;\r\n\t\tif ( cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tif ( cy < cminy ) cminy = cy;\r\n\t\tif ( cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tif ( cz < cminz ) cminz = cz;\r\n\t\tif ( cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\tcentroidTarget[ 0 ] = cminx;\r\n\tcentroidTarget[ 1 ] = cminy;\r\n\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\tcentroidTarget[ 3 ] = cmaxx;\r\n\tcentroidTarget[ 4 ] = cmaxy;\r\n\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n}\r\n\r\n\r\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n// of the first element on the right side, or offset + count if there are no elements on the right side.\r\nfunction partition( index, triangleBounds, offset, count, split ) {\r\n\r\n\tlet left = offset;\r\n\tlet right = offset + count - 1;\r\n\tconst pos = split.pos;\r\n\tconst axisOffset = split.axis * 2;\r\n\r\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\twhile ( true ) {\r\n\r\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\tleft ++;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\r\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\tright --;\r\n\r\n\t\t}\r\n\r\n\t\tif ( left < right ) {\r\n\r\n\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\r\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\r\n\r\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tleft ++;\r\n\t\t\tright --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn left;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst BIN_COUNT = 32;\r\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\r\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\r\n\r\n\treturn {\r\n\r\n\t\tcount: 0,\r\n\t\tbounds: new Float32Array( 6 ),\r\n\t\trightCacheBounds: new Float32Array( 6 ),\r\n\t\tleftCacheBounds: new Float32Array( 6 ),\r\n\t\tcandidate: 0,\r\n\r\n\t};\r\n\r\n} );\r\nconst leftBounds = new Float32Array( 6 );\r\n\r\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\r\n\r\n\tlet axis = - 1;\r\n\tlet pos = 0;\r\n\r\n\t// Center\r\n\tif ( strategy === CENTER ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === SAH ) {\r\n\r\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\r\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t// iterate over all axes\r\n\t\tconst cStart = offset * 6;\r\n\t\tconst cEnd = ( offset + count ) * 6;\r\n\t\tfor ( let a = 0; a < 3; a ++ ) {\r\n\r\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\r\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\r\n\t\t\tconst axisLength = axisRight - axisLeft;\r\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\r\n\r\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\r\n\t\t\t// the triangle positions because it will be faster.\r\n\t\t\tif ( count < BIN_COUNT / 4 ) {\r\n\r\n\t\t\t\t// initialize the bin candidates\r\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\r\n\t\t\t\ttruncatedBins.length = count;\r\n\r\n\t\t\t\t// set the candidates\r\n\t\t\t\tlet b = 0;\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ b ];\r\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tbin.count = 0;\r\n\r\n\t\t\t\t\tconst {\r\n\t\t\t\t\t\tbounds,\r\n\t\t\t\t\t\tleftCacheBounds,\r\n\t\t\t\t\t\trightCacheBounds,\r\n\t\t\t\t\t} = bin;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttruncatedBins.sort( binsSort );\r\n\r\n\t\t\t\t// remove redundant splits\r\n\t\t\t\tlet splitCount = count;\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\r\n\r\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\r\n\t\t\t\t\t\tsplitCount --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\r\n\t\t\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// expand all the bounds\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\tconst leftCount = bin.count;\r\n\t\t\t\t\tconst rightCount = count - bin.count;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\r\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\r\n\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet rightProb = 0;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset the bins\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tbin.count = 0;\r\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\r\n\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over all center positions\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\r\n\r\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\r\n\t\t\t\t\t// considered to be on the right side of the split\r\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\r\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\r\n\r\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\r\n\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\r\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\r\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\r\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet leftCount = 0;\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst binCount = bin.count;\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\r\n\r\n\t\t\t\t\t// dont do anything with the bounds if the new bounds have no triangles\r\n\t\t\t\t\tif ( binCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tif ( leftCount === 0 ) {\r\n\r\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tleftCount += binCount;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tlet rightProb = 0;\r\n\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst rightCount = count - leftCount;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\r\n\r\n\t}\r\n\r\n\treturn { axis, pos };\r\n\r\n}\r\n\r\n// returns the average coordinate on the specified axis of the all the provided triangles\r\nfunction getAverage( triangleBounds, offset, count, axis ) {\r\n\r\n\tlet avg = 0;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\r\n\r\n\t}\r\n\r\n\treturn avg / count;\r\n\r\n}\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nfunction computeTriangleBounds( geo, fullBounds ) {\r\n\r\n\tconst posAttr = geo.attributes.position;\r\n\tconst posArr = posAttr.array;\r\n\tconst index = geo.index.array;\r\n\tconst triCount = index.length / 3;\r\n\tconst triangleBounds = new Float32Array( triCount * 6 );\r\n\r\n\t// support for an interleaved position buffer\r\n\tconst bufferOffset = posAttr.offset || 0;\r\n\tlet stride = 3;\r\n\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tstride = posAttr.data.stride;\r\n\r\n\t}\r\n\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tconst tri3 = tri * 3;\r\n\t\tconst tri6 = tri * 6;\r\n\t\tconst ai = index[ tri3 + 0 ] * stride + bufferOffset;\r\n\t\tconst bi = index[ tri3 + 1 ] * stride + bufferOffset;\r\n\t\tconst ci = index[ tri3 + 2 ] * stride + bufferOffset;\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tconst a = posArr[ ai + el ];\r\n\t\t\tconst b = posArr[ bi + el ];\r\n\t\t\tconst c = posArr[ ci + el ];\r\n\r\n\t\t\tlet min = a;\r\n\t\t\tif ( b < min ) min = b;\r\n\t\t\tif ( c < min ) min = c;\r\n\r\n\t\t\tlet max = a;\r\n\t\t\tif ( b > max ) max = b;\r\n\t\t\tif ( c > max ) max = c;\r\n\r\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\r\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\r\n\t\t\t// worked with.\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tconst el2 = el * 2;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\r\n\r\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\r\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn triangleBounds;\r\n\r\n}\r\n\r\nexport function buildTree( geo, options ) {\r\n\r\n\tfunction triggerProgress( trianglesProcessed ) {\r\n\r\n\t\tif ( onProgress ) {\r\n\r\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( geo );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\t\t\tleft.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\t\t\tright.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tensureIndex( geo, options );\r\n\r\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\r\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\r\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\r\n\tconst fullBounds = new Float32Array( 6 );\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\r\n\tconst indexArray = geo.index.array;\r\n\tconst maxDepth = options.maxDepth;\r\n\tconst verbose = options.verbose;\r\n\tconst maxLeafTris = options.maxLeafTris;\r\n\tconst strategy = options.strategy;\r\n\tconst onProgress = options.onProgress;\r\n\tconst totalTriangles = geo.index.count / 3;\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst roots = [];\r\n\tconst ranges = getRootIndexRanges( geo );\r\n\r\n\tif ( ranges.length === 1 ) {\r\n\r\n\t\tconst range = ranges[ 0 ];\r\n\t\tconst root = new MeshBVHNode();\r\n\t\troot.boundingData = fullBounds;\r\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\r\n\r\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\troots.push( root );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\troot.boundingData = new Float32Array( 6 );\r\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\t\troots.push( root );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn roots;\r\n\r\n}\r\n\r\nexport function buildPackedTree( geo, options ) {\r\n\r\n\t// boundingData  \t\t\t\t: 6 float32\r\n\t// right / offset \t\t\t\t: 1 uint32\r\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\r\n\tconst roots = buildTree( geo, options );\r\n\r\n\tlet float32Array;\r\n\tlet uint32Array;\r\n\tlet uint16Array;\r\n\tconst packedRoots = [];\r\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\tfor ( let i = 0; i < roots.length; i ++ ) {\r\n\r\n\t\tconst root = roots[ i ];\r\n\t\tlet nodeCount = countNodes( root );\r\n\r\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tpopulateBuffer( 0, root );\r\n\t\tpackedRoots.push( buffer );\r\n\r\n\t}\r\n\r\n\treturn packedRoots;\r\n\r\n\tfunction countNodes( node ) {\r\n\r\n\t\tif ( node.count ) {\r\n\r\n\t\t\treturn 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction populateBuffer( byteOffset, node ) {\r\n\r\n\t\tconst stride4Offset = byteOffset / 4;\r\n\t\tconst stride2Offset = byteOffset / 2;\r\n\t\tconst isLeaf = ! ! node.count;\r\n\t\tconst boundingData = node.boundingData;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = node.offset;\r\n\t\t\tconst count = node.count;\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\r\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\r\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\r\n\t\t\treturn byteOffset + BYTES_PER_NODE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node.left;\r\n\t\t\tconst right = node.right;\r\n\t\t\tconst splitAxis = node.splitAxis;\r\n\r\n\t\t\tlet nextUnusedPointer;\r\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\r\n\r\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\r\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\r\n\r\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\r\n\t\t\treturn nextUnusedPointer;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Vector3 } from 'three';\r\n\r\nexport class SeparatingAxisBounds {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.min = Infinity;\r\n\t\tthis.max = - Infinity;\r\n\r\n\t}\r\n\r\n\tsetFromPointsField( points, field ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = p[ field ];\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tsetFromPoints( axis, points ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = axis.dot( p );\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tisSeparated( other ) {\r\n\r\n\t\treturn this.min > other.max || other.min > this.max;\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\r\n\r\n\tconst p = new Vector3();\r\n\treturn function setFromBox( axis, box ) {\r\n\r\n\t\tconst boxMin = box.min;\r\n\t\tconst boxMax = box.max;\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\r\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\r\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\r\n\r\n\t\t\t\t\tconst val = axis.dot( p );\r\n\t\t\t\t\tmin = Math.min( val, min );\r\n\t\t\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const areIntersecting = ( function () {\r\n\r\n\tconst cacheSatBounds = new SeparatingAxisBounds();\r\n\treturn function areIntersecting( shape1, shape2 ) {\r\n\r\n\t\tconst points1 = shape1.points;\r\n\t\tconst satAxes1 = shape1.satAxes;\r\n\t\tconst satBounds1 = shape1.satBounds;\r\n\r\n\t\tconst points2 = shape2.points;\r\n\t\tconst satAxes2 = shape2.satAxes;\r\n\t\tconst satBounds2 = shape2.satBounds;\r\n\r\n\t\t// check axes of the first shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check axes of the second shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\r\n\r\nexport const closestPointLineToLine = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst v02 = new Vector3();\r\n\treturn function closestPointLineToLine( l1, l2, result ) {\r\n\r\n\t\tconst v0 = l1.start;\r\n\t\tconst v10 = dir1;\r\n\t\tconst v2 = l2.start;\r\n\t\tconst v32 = dir2;\r\n\r\n\t\tv02.subVectors( v0, v2 );\r\n\t\tdir1.subVectors( l1.end, l2.start );\r\n\t\tdir2.subVectors( l2.end, l2.start );\r\n\r\n\t\t// float d0232 = v02.Dot(v32);\r\n\t\tconst d0232 = v02.dot( v32 );\r\n\r\n\t\t// float d3210 = v32.Dot(v10);\r\n\t\tconst d3210 = v32.dot( v10 );\r\n\r\n\t\t// float d3232 = v32.Dot(v32);\r\n\t\tconst d3232 = v32.dot( v32 );\r\n\r\n\t\t// float d0210 = v02.Dot(v10);\r\n\t\tconst d0210 = v02.dot( v10 );\r\n\r\n\t\t// float d1010 = v10.Dot(v10);\r\n\t\tconst d1010 = v10.dot( v10 );\r\n\r\n\t\t// float denom = d1010*d3232 - d3210*d3210;\r\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\r\n\r\n\t\tlet d, d2;\r\n\t\tif ( denom !== 0 ) {\r\n\r\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\r\n\r\n\t\t} else {\r\n\r\n\t\t\td = 0;\r\n\r\n\t\t}\r\n\r\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\r\n\r\n\t\tresult.x = d;\r\n\t\tresult.y = d2;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const closestPointsSegmentToSegment = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\r\n\tconst paramResult = new Vector2();\r\n\tconst temp1 = new Vector3();\r\n\tconst temp2 = new Vector3();\r\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\r\n\r\n\t\tclosestPointLineToLine( l1, l2, paramResult );\r\n\r\n\t\tlet d = paramResult.x;\r\n\t\tlet d2 = paramResult.y;\r\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\tl1.at( d, target1 );\r\n\t\t\tl2.at( d2, target2 );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d >= 0 && d <= 1 ) {\r\n\r\n\t\t\t// Only d2 is out of bounds.\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tl2.at( 0, target2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl2.at( 1, target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\t// Only d is out of bounds.\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tl1.at( 0, target1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl1.at( 1, target1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Both u and u2 are out of bounds.\r\n\t\t\tlet p;\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tp = l1.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp = l1.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet p2;\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tp2 = l2.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp2 = l2.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst closestPoint = temp1;\r\n\t\t\tconst closestPoint2 = temp2;\r\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\r\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\r\n\r\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\r\n\r\n\t\t\t\ttarget1.copy( closestPoint );\r\n\t\t\t\ttarget2.copy( p2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget1.copy( p );\r\n\t\t\t\ttarget2.copy( closestPoint2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nexport const sphereIntersectTriangle = ( function () {\r\n\r\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\r\n\tconst closestPointTemp = new Vector3();\r\n\tconst projectedPointTemp = new Vector3();\r\n\tconst planeTemp = new Plane();\r\n\tconst lineTemp = new Line3();\r\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\r\n\r\n\t\tconst { radius, center } = sphere;\r\n\t\tconst { a, b, c } = triangle;\r\n\r\n\t\t// phase 1\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = b;\r\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = b;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\t// phase 2\r\n\t\tconst plane = triangle.getPlane( planeTemp );\r\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\r\n\t\tif ( dp <= radius ) {\r\n\r\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\r\n\t\t\tconst cp = triangle.containsPoint( pp );\r\n\t\t\tif ( cp ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\r\n\r\nexport class ExtendedTriangle extends Triangle {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isExtendedTriangle = true;\r\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.points = [ this.a, this.b, this.c ];\r\n\t\tthis.sphere = new Sphere();\r\n\t\tthis.plane = new Plane();\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn sphereIntersectTriangle( sphere, this );\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst a = this.a;\r\n\t\tconst b = this.b;\r\n\t\tconst c = this.c;\r\n\t\tconst points = this.points;\r\n\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst satBounds = this.satBounds;\r\n\r\n\t\tconst axis0 = satAxes[ 0 ];\r\n\t\tconst sab0 = satBounds[ 0 ];\r\n\t\tthis.getNormal( axis0 );\r\n\t\tsab0.setFromPoints( axis0, points );\r\n\r\n\t\tconst axis1 = satAxes[ 1 ];\r\n\t\tconst sab1 = satBounds[ 1 ];\r\n\t\taxis1.subVectors( a, b );\r\n\t\tsab1.setFromPoints( axis1, points );\r\n\r\n\t\tconst axis2 = satAxes[ 2 ];\r\n\t\tconst sab2 = satBounds[ 2 ];\r\n\t\taxis2.subVectors( b, c );\r\n\t\tsab2.setFromPoints( axis2, points );\r\n\r\n\t\tconst axis3 = satAxes[ 3 ];\r\n\t\tconst sab3 = satBounds[ 3 ];\r\n\t\taxis3.subVectors( c, a );\r\n\t\tsab3.setFromPoints( axis3, points );\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst edge = new Line3();\r\n\r\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\r\n\r\n\t\tconst { start, end } = segment;\r\n\t\tconst points = this.points;\r\n\t\tlet distSq;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check the triangle edges\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst nexti = ( i + 1 ) % 3;\r\n\t\t\tedge.start.copy( points[ i ] );\r\n\t\t\tedge.end.copy( points[ nexti ] );\r\n\r\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\r\n\r\n\t\t\tdistSq = point1.distanceToSquared( point2 );\r\n\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check end points\r\n\t\tthis.closestPointToPoint( start, point1 );\r\n\t\tdistSq = start.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( start );\r\n\r\n\t\t}\r\n\r\n\t\tthis.closestPointToPoint( end, point1 );\r\n\t\tdistSq = end.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( end );\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri2 = new ExtendedTriangle();\r\n\tconst arr1 = new Array( 3 );\r\n\tconst arr2 = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst tempDir = new Vector3();\r\n\tconst edge = new Line3();\r\n\tconst edge1 = new Line3();\r\n\tconst edge2 = new Line3();\r\n\r\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\r\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\r\n\treturn function intersectsTriangle( other, target = null ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! other.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri2.copy( other );\r\n\t\t\tsaTri2.update();\r\n\t\t\tother = saTri2;\r\n\r\n\t\t} else if ( other.needsUpdate ) {\r\n\r\n\t\t\tother.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst plane1 = this.plane;\r\n\t\tconst plane2 = other.plane;\r\n\r\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\r\n\r\n\t\t\t// perform separating axis intersection test only for coplanar triangles\r\n\t\t\tconst satBounds1 = this.satBounds;\r\n\t\t\tconst satAxes1 = this.satAxes;\r\n\t\t\tarr2[ 0 ] = other.a;\r\n\t\t\tarr2[ 1 ] = other.b;\r\n\t\t\tarr2[ 2 ] = other.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst satBounds2 = other.satBounds;\r\n\t\t\tconst satAxes2 = other.satAxes;\r\n\t\t\tarr1[ 0 ] = this.a;\r\n\t\t\tarr1[ 1 ] = this.b;\r\n\t\t\tarr1[ 2 ] = this.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check crossed axes\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sa1 = satAxes1[ i ];\r\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\r\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\r\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\r\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\r\n\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\r\n\r\n\t\t\t\ttarget.start.set( 0, 0, 0 );\r\n\t\t\t\ttarget.end.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the edge that intersects the other triangle plane\r\n\t\t\tconst points1 = this.points;\r\n\t\t\tlet found1 = false;\r\n\t\t\tlet count1 = 0;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst p1 = points1[ i ];\r\n\t\t\t\tconst p2 = points1[ ( i + 1 ) % 3 ];\r\n\r\n\t\t\t\tedge.start.copy( p1 );\r\n\t\t\t\tedge.end.copy( p2 );\r\n\t\t\t\tedge.delta( dir1 );\r\n\t\t\t\tif ( plane2.normal.dot( dir1 ) === 0 && plane2.distanceToPoint( edge.start ) === 0 ) {\r\n\r\n\t\t\t\t\t// if the edge lies on the plane then take the line\r\n\t\t\t\t\tedge1.copy( edge );\r\n\t\t\t\t\tcount1 = 2;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t} else if ( plane2.intersectLine( edge, found1 ? edge1.start : edge1.end ) ) {\r\n\r\n\t\t\t\t\tcount1 ++;\r\n\t\t\t\t\tif ( found1 ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfound1 = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( count1 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find the other triangles edge that intersects this plane\r\n\t\t\tconst points2 = other.points;\r\n\t\t\tlet found2 = false;\r\n\t\t\tlet count2 = 0;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst p1 = points2[ i ];\r\n\t\t\t\tconst p2 = points2[ ( i + 1 ) % 3 ];\r\n\r\n\t\t\t\tedge.start.copy( p1 );\r\n\t\t\t\tedge.end.copy( p2 );\r\n\t\t\t\tedge.delta( dir2 );\r\n\t\t\t\tif ( plane1.normal.dot( dir2 ) === 0 && plane1.distanceToPoint( edge.start ) === 0 ) {\r\n\r\n\t\t\t\t\t// if the edge lies on the plane then take the line\r\n\t\t\t\t\tedge2.copy( edge );\r\n\t\t\t\t\tcount2 = 2;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t} else if ( plane1.intersectLine( edge, found2 ? edge2.start : edge2.end ) ) {\r\n\r\n\t\t\t\t\tcount2 ++;\r\n\t\t\t\t\tif ( found2 ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfound2 = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( count2 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find swap the second edge so both lines are running the same direction\r\n\t\t\tedge1.delta( dir1 );\r\n\t\t\tedge2.delta( dir2 );\r\n\r\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\r\n\r\n\t\t\t\tlet tmp = edge2.start;\r\n\t\t\t\tedge2.start = edge2.end;\r\n\t\t\t\tedge2.end = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if the edges are overlapping\r\n\t\t\tconst s1 = edge1.start.dot( dir1 );\r\n\t\t\tconst e1 = edge1.end.dot( dir1 );\r\n\t\t\tconst s2 = edge2.start.dot( dir1 );\r\n\t\t\tconst e2 = edge2.end.dot( dir1 );\r\n\t\t\tconst separated1 = e1 < s2;\r\n\t\t\tconst separated2 = s1 < e2;\r\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// assign the target output\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge1.start );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge2.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge1.end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge2.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\r\n\r\n\tconst point = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst cornerFields = [ 'a', 'b', 'c' ];\r\n\tconst line1 = new Line3();\r\n\tconst line2 = new Line3();\r\n\r\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\r\n\r\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\r\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\r\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check all point distances\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tlet dist;\r\n\t\t\tconst field = cornerFields[ i ];\r\n\t\t\tconst otherVec = other[ field ];\r\n\t\t\tthis.closestPointToPoint( otherVec, point );\r\n\r\n\t\t\tdist = otherVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst thisVec = this[ field ];\r\n\t\t\tother.closestPointToPoint( thisVec, point );\r\n\r\n\t\t\tdist = thisVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\r\n\t\t\t\tif ( target2 ) target2.copy( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst f11 = cornerFields[ i ];\r\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\r\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\r\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\r\n\r\n\t\t\t\tconst f21 = cornerFields[ i2 ];\r\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\r\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\r\n\r\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\r\n\r\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Box3, Vector3, Matrix4, Line3 } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class OrientedBox extends Box3 {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isOrientedBox = true;\r\n\t\tthis.matrix = new Matrix4();\r\n\t\tthis.invMatrix = new Matrix4();\r\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\r\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n\tset( min, max, matrix ) {\r\n\r\n\t\tsuper.set( min, max );\r\n\t\tthis.matrix.copy( matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\t\tthis.matrix.copy( other.matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\nOrientedBox.prototype.update = ( function () {\r\n\r\n\treturn function update() {\r\n\r\n\t\tconst matrix = this.matrix;\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\tconst points = this.points;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\r\n\t\t\t\t\tconst v = points[ i ];\r\n\t\t\t\t\tv.x = x ? max.x : min.x;\r\n\t\t\t\t\tv.y = y ? max.y : min.y;\r\n\t\t\t\t\tv.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tv.applyMatrix4( matrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst minVec = points[ 0 ];\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst index = 1 << i;\r\n\t\t\tconst pi = points[ index ];\r\n\r\n\t\t\taxis.subVectors( minVec, pi );\r\n\t\t\tsb.setFromPoints( axis, points );\r\n\r\n\t\t}\r\n\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\r\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\r\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\r\n\r\n\t\tthis.invMatrix.copy( this.matrix ).invert();\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsBox = ( function () {\r\n\r\n\tconst aabbBounds = new SeparatingAxisBounds();\r\n\treturn function intersectsBox( box ) {\r\n\r\n\t\t// TODO: should this be doing SAT against the AABB?\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\r\n\t\taabbBounds.min = min.x;\r\n\t\taabbBounds.max = max.x;\r\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.y;\r\n\t\taabbBounds.max = max.y;\r\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.z;\r\n\t\taabbBounds.max = max.z;\r\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\taabbBounds.setFromBox( axis, box );\r\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri = new ExtendedTriangle();\r\n\tconst pointsArr = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! triangle.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri.copy( triangle );\r\n\t\t\tsaTri.update();\r\n\t\t\ttriangle = saTri;\r\n\r\n\t\t} else if ( triangle.needsUpdate ) {\r\n\r\n\t\t\ttriangle.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\r\n\t\tpointsArr[ 0 ] = triangle.a;\r\n\t\tpointsArr[ 1 ] = triangle.b;\r\n\t\tpointsArr[ 2 ] = triangle.c;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst sa = satAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst triSatBounds = triangle.satBounds;\r\n\t\tconst triSatAxes = triangle.satAxes;\r\n\t\tconst points = this.points;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = triSatBounds[ i ];\r\n\t\t\tconst sa = triSatAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.closestPointToPoint = ( function () {\r\n\r\n\treturn function closestPointToPoint( point, target1 ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\ttarget1\r\n\t\t\t.copy( point )\r\n\t\t\t.applyMatrix4( this.invMatrix )\r\n\t\t\t.clamp( this.min, this.max )\r\n\t\t\t.applyMatrix4( this.matrix );\r\n\r\n\t\treturn target1;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToBox = ( function () {\r\n\r\n\tconst xyzFields = [ 'x', 'y', 'z' ];\r\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\r\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\r\n\t// early out if we find a value below threshold\r\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.intersectsBox( box ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tbox.getCenter( point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst threshold2 = threshold * threshold;\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst points = this.points;\r\n\r\n\r\n\t\t// iterate over every edge and compare distances\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check over all these points\r\n\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tpoint2.copy( p ).clamp( min, max );\r\n\r\n\t\t\tconst dist = p.distanceToSquared( point2 );\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( p );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate and check all line segment distances\r\n\t\tlet count = 0;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\r\n\r\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\r\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\t\t// get obb line segments\r\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst p1 = points[ index ];\r\n\t\t\t\t\tconst p2 = points[ index2 ];\r\n\t\t\t\t\tconst line1 = segments1[ count ];\r\n\t\t\t\t\tline1.set( p1, p2 );\r\n\r\n\r\n\t\t\t\t\t// get aabb line segments\r\n\t\t\t\t\tconst f1 = xyzFields[ i ];\r\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\r\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\r\n\t\t\t\t\tconst line2 = segments2[ count ];\r\n\t\t\t\t\tconst start = line2.start;\r\n\t\t\t\t\tconst end = line2.end;\r\n\r\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\r\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\r\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tcount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check all the other boxes point\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\r\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\r\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\r\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 12; i ++ ) {\r\n\r\n\t\t\tconst l1 = segments1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\r\n\r\n\t\t\t\tconst l2 = segments2[ i2 ];\r\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\r\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","\r\nimport { Vector2, Vector3, Triangle } from 'three';\r\n\r\n// sets the vertices of triangle `tri` with the 3 vertices after i\r\nexport function setTriangle( tri, i, index, pos ) {\r\n\r\n\tconst ta = tri.a;\r\n\tconst tb = tri.b;\r\n\tconst tc = tri.c;\r\n\r\n\tlet i0 = i;\r\n\tlet i1 = i + 1;\r\n\tlet i2 = i + 2;\r\n\tif ( index ) {\r\n\r\n\t\ti0 = index.getX( i );\r\n\t\ti1 = index.getX( i + 1 );\r\n\t\ti2 = index.getX( i + 2 );\r\n\r\n\t}\r\n\r\n\tta.x = pos.getX( i0 );\r\n\tta.y = pos.getY( i0 );\r\n\tta.z = pos.getZ( i0 );\r\n\r\n\ttb.x = pos.getX( i1 );\r\n\ttb.y = pos.getY( i1 );\r\n\ttb.z = pos.getZ( i1 );\r\n\r\n\ttc.x = pos.getX( i2 );\r\n\ttc.y = pos.getY( i2 );\r\n\ttc.z = pos.getZ( i2 );\r\n\r\n}\r\n\r\nexport function iterateOverTriangles(\r\n\toffset,\r\n\tcount,\r\n\tgeometry,\r\n\tintersectsTriangleFunc,\r\n\tcontained,\r\n\tdepth,\r\n\ttriangle\r\n) {\r\n\r\n\tconst index = geometry.index;\r\n\tconst pos = geometry.attributes.position;\r\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\r\n\r\n\t\tsetTriangle( triangle, i * 3, index, pos );\r\n\t\ttriangle.needsUpdate = true;\r\n\r\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\nconst tempV1 = /* @__PURE__ */ new Vector3();\r\nconst tempV2 = /* @__PURE__ */ new Vector3();\r\nconst tempV3 = /* @__PURE__ */ new Vector3();\r\nconst tempUV1 = /* @__PURE__ */ new Vector2();\r\nconst tempUV2 = /* @__PURE__ */ new Vector2();\r\nconst tempUV3 = /* @__PURE__ */ new Vector2();\r\n\r\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\r\n\r\n\tconst indices = geometry.getIndex().array;\r\n\tconst positions = geometry.getAttribute( 'position' );\r\n\tconst uvs = geometry.getAttribute( 'uv' );\r\n\r\n\tconst a = indices[ triangleIndex * 3 ];\r\n\tconst b = indices[ triangleIndex * 3 + 1 ];\r\n\tconst c = indices[ triangleIndex * 3 + 2 ];\r\n\r\n\ttempV1.fromBufferAttribute( positions, a );\r\n\ttempV2.fromBufferAttribute( positions, b );\r\n\ttempV3.fromBufferAttribute( positions, c );\r\n\r\n\t// find the associated material index\r\n\tlet materialIndex = 0;\r\n\tconst groups = geometry.groups;\r\n\tconst firstVertexIndex = triangleIndex * 3;\r\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst { start, count } = group;\r\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\r\n\r\n\t\t\tmaterialIndex = group.materialIndex;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// extract uvs\r\n\tlet uv = null;\r\n\tif ( uvs ) {\r\n\r\n\t\ttempUV1.fromBufferAttribute( uvs, a );\r\n\t\ttempUV2.fromBufferAttribute( uvs, b );\r\n\t\ttempUV3.fromBufferAttribute( uvs, c );\r\n\r\n\t\tif ( target && target.uv ) uv = target.uv;\r\n\t\telse uv = new Vector2();\r\n\r\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\r\n\r\n\t}\r\n\r\n\t// adjust the provided target or create a new one\r\n\tif ( target ) {\r\n\r\n\t\tif ( ! target.face ) target.face = { };\r\n\t\ttarget.face.a = a;\r\n\t\ttarget.face.b = b;\r\n\t\ttarget.face.c = c;\r\n\t\ttarget.face.materialIndex = materialIndex;\r\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\r\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\r\n\r\n\t\tif ( ! target.uv ) target.uv = new Vector2();\r\n\t\ttarget.uv.copy( uv );\r\n\r\n\t\treturn target;\r\n\r\n\t} else {\r\n\r\n\t\treturn {\r\n\t\t\tface: {\r\n\t\t\t\ta: a,\r\n\t\t\t\tb: b,\r\n\t\t\t\tc: c,\r\n\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\r\n\t\t\t},\r\n\t\t\tuv: uv\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","export class PrimitivePool {\r\n\r\n\tconstructor( getNewPrimitive ) {\r\n\r\n\t\tthis._getNewPrimitive = getNewPrimitive;\r\n\t\tthis._primitives = [];\r\n\r\n\t}\r\n\r\n\tgetPrimitive() {\r\n\r\n\t\tconst primitives = this._primitives;\r\n\t\tif ( primitives.length === 0 ) {\r\n\r\n\t\t\treturn this._getNewPrimitive();\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn primitives.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treleasePrimitive( primitive ) {\r\n\r\n\t\tthis._primitives.push( primitive );\r\n\r\n\t}\r\n\r\n}\r\n","export function IS_LEAF( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\r\n\r\n}\r\n\r\nexport function OFFSET( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function COUNT( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 14 ];\r\n\r\n}\r\n\r\nexport function LEFT_NODE( n32 ) {\r\n\r\n\treturn n32 + 8;\r\n\r\n}\r\n\r\nexport function RIGHT_NODE( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function SPLIT_AXIS( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 7 ];\r\n\r\n}\r\n\r\nexport function BOUNDING_DATA_INDEX( n32 ) {\r\n\r\n\treturn n32;\r\n\r\n}\r\n","import { Box3, Vector3, Matrix4 } from 'three';\r\nimport { CONTAINED } from './Constants.js';\r\n\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\r\nimport { setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\r\n\r\nconst boundingBox = new Box3();\r\nconst boxIntersection = new Vector3();\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\r\n\r\n\t} else {\r\n\r\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\r\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\r\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\r\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\t// \"point\" is in the local frame of the bvh\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\r\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const shapecast = ( function () {\r\n\r\n\tlet _box1, _box2;\r\n\tconst boxStack = [];\r\n\tconst boxPool = new PrimitivePool( () => new Box3() );\r\n\r\n\treturn function shapecast( ...args ) {\r\n\r\n\t\t_box1 = boxPool.getPrimitive();\r\n\t\t_box2 = boxPool.getPrimitive();\r\n\t\tboxStack.push( _box1, _box2 );\r\n\r\n\t\tconst result = shapecastTraverse( ...args );\r\n\r\n\t\tboxPool.releasePrimitive( _box1 );\r\n\t\tboxPool.releasePrimitive( _box2 );\r\n\t\tboxStack.pop();\r\n\t\tboxStack.pop();\r\n\r\n\t\tconst length = boxStack.length;\r\n\t\tif ( length > 0 ) {\r\n\r\n\t\t\t_box2 = boxStack[ length - 1 ];\r\n\t\t\t_box1 = boxStack[ length - 2 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tfunction shapecastTraverse(\r\n\t\tnodeIndex32,\r\n\t\tgeometry,\r\n\t\tintersectsBoundsFunc,\r\n\t\tintersectsRangeFunc,\r\n\t\tnodeScoreFunc = null,\r\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\r\n\t\tdepth = 0\r\n\t) {\r\n\r\n\t\t// Define these inside the function so it has access to the local variables needed\r\n\t\t// when converting to the buffer equivalents\r\n\t\tfunction getLeftOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\t// adjust offset to point to the right node\r\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return the end offset of the triangle range\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t}\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\r\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\r\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tlet c1 = left;\r\n\t\t\tlet c2 = right;\r\n\r\n\t\t\tlet score1, score2;\r\n\t\t\tlet box1, box2;\r\n\t\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tbox2 = _box2;\r\n\r\n\t\t\t\t// bounding data is not offset\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\t\tc1 = right;\r\n\t\t\t\t\tc2 = left;\r\n\r\n\t\t\t\t\tconst temp = score1;\r\n\t\t\t\t\tscore1 = score2;\r\n\t\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\t\tbox1 = box2;\r\n\t\t\t\t\t// box2 is always set before use below\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check box 1 intersection\r\n\t\t\tif ( ! box1 ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\r\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\r\n\r\n\t\t\tlet c1StopTraversal;\r\n\t\t\tif ( c1Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c1 );\r\n\t\t\t\tconst end = getRightEndOffset( c1 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc1StopTraversal =\r\n\t\t\t\t\tc1Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc1,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c1StopTraversal ) return true;\r\n\r\n\t\t\t// Check box 2 intersection\r\n\t\t\t// cached box2 will have been overwritten by previous traversal\r\n\t\t\tbox2 = _box2;\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\r\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\r\n\r\n\t\t\tlet c2StopTraversal;\r\n\t\t\tif ( c2Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c2 );\r\n\t\t\t\tconst end = getRightEndOffset( c2 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc2StopTraversal =\r\n\t\t\t\t\tc2Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc2,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c2StopTraversal ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} )();\r\n\r\nexport const intersectsGeometry = ( function () {\r\n\r\n\tconst triangle = new ExtendedTriangle();\r\n\tconst triangle2 = new ExtendedTriangle();\r\n\tconst invertedMat = new Matrix4();\r\n\r\n\tconst obb = new OrientedBox();\r\n\tconst obb2 = new OrientedBox();\r\n\r\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tif ( cachedObb === null ) {\r\n\r\n\t\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\t\tcachedObb = obb;\r\n\r\n\t\t}\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst thisGeometry = geometry;\r\n\t\t\tconst thisIndex = thisGeometry.index;\r\n\t\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\t\tconst index = otherGeometry.index;\r\n\t\t\tconst pos = otherGeometry.attributes.position;\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t\t// here.\r\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\r\n\r\n\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\r\n\t\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = nodeIndex32 + 8;\r\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\r\n\t\t\tconst leftIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( leftIntersection ) return true;\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\r\n\t\t\tconst rightIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( rightIntersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nfunction intersectRay( nodeIndex32, array, ray, target ) {\r\n\r\n\tarrayToBox( nodeIndex32, array, boundingBox );\r\n\treturn ray.intersectBox( boundingBox, target );\r\n\r\n}\r\n\r\nconst bufferStack = [];\r\nlet _prevBuffer;\r\nlet _float32Array;\r\nlet _uint16Array;\r\nlet _uint32Array;\r\nexport function setBuffer( buffer ) {\r\n\r\n\tif ( _prevBuffer ) {\r\n\r\n\t\tbufferStack.push( _prevBuffer );\r\n\r\n\t}\r\n\r\n\t_prevBuffer = buffer;\r\n\t_float32Array = new Float32Array( buffer );\r\n\t_uint16Array = new Uint16Array( buffer );\r\n\t_uint32Array = new Uint32Array( buffer );\r\n\r\n}\r\n\r\nexport function clearBuffer() {\r\n\r\n\t_prevBuffer = null;\r\n\t_float32Array = null;\r\n\t_uint16Array = null;\r\n\t_uint32Array = null;\r\n\r\n\tif ( bufferStack.length ) {\r\n\r\n\t\tsetBuffer( bufferStack.pop() );\r\n\r\n\t}\r\n\r\n}\r\n","import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\r\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\r\nimport { buildPackedTree } from './buildFunctions.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst aabb = /* @__PURE__ */ new Box3();\r\nconst aabb2 = /* @__PURE__ */ new Box3();\r\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\nconst temp = /* @__PURE__ */ new Vector3();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\nconst temp2 = /* @__PURE__ */ new Vector3();\r\nconst temp3 = /* @__PURE__ */ new Vector3();\r\nconst temp4 = /* @__PURE__ */ new Vector3();\r\nconst tempBox = /* @__PURE__ */ new Box3();\r\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\r\n\r\nexport class MeshBVH {\r\n\r\n\tstatic serialize( bvh, options = {} ) {\r\n\r\n\t\tif ( options.isBufferGeometry ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.serialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tcloneBuffers: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst geometry = bvh.geometry;\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tlet result;\r\n\t\tif ( options.cloneBuffers ) {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData.map( root => root.slice() ),\r\n\t\t\t\tindex: indexAttribute.array.slice(),\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData,\r\n\t\t\t\tindex: indexAttribute.array,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, options = {} ) {\r\n\r\n\t\tif ( typeof options === 'boolean' ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.deserialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\targuments[ 1 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tsetIndex: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( options.setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\t\t\tuseSharedArrayBuffer: false,\r\n\t\t\tsetBoundingBox: true,\r\n\t\t\tonProgress: null,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false,\r\n\r\n\t\t}, options );\r\n\r\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\t\tconst posArr = posAttr.array;\r\n\r\n\t\t// support for an interleaved position buffer\r\n\t\tconst bufferOffset = posAttr.offset || 0;\r\n\t\tlet stride = 3;\r\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tstride = posAttr.data.stride;\r\n\r\n\t\t}\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\r\n\t\t\t\t\tconst x = posArr[ index + 0 ];\r\n\t\t\t\t\tconst y = posArr[ index + 1 ];\r\n\t\t\t\t\tconst z = posArr[ index + 2 ];\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\t\tlet forceChildren = force;\r\n\t\t\t\tlet includesLeft = false;\r\n\t\t\t\tlet includesRight = false;\r\n\r\n\t\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tincludesLeft = true;\r\n\t\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// TODO: use node functions here\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst intersects = [];\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst startCount = intersects.length;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\r\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\traycastFirst( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\t\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\r\n\r\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\r\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\r\n\r\n\t\tlet {\r\n\t\t\tintersectsRanges,\r\n\t\t\tintersectsTriangles,\r\n\t\t} = callbacks;\r\n\r\n\t\tconst indexAttr = this.geometry.index;\r\n\t\tconst positionAttr = this.geometry.attributes.position;\r\n\r\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\r\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\r\n\r\n\t\ttempMatrix.copy( matrixToLocal ).invert();\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tif ( intersectsTriangles ) {\r\n\r\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\r\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\r\n\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( intersectsRanges ) {\r\n\r\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\r\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.getBoundingBox( aabb2 );\r\n\t\taabb2.applyMatrix4( matrixToLocal );\r\n\t\tconst result = this.shapecast( {\r\n\r\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\r\n\r\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\r\n\r\n\t\t\t\taabb.copy( box );\r\n\t\t\t\taabb.applyMatrix4( tempMatrix );\r\n\t\t\t\treturn otherBvh.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\r\n\r\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tlet tempTarget1 = temp1;\r\n\t\tlet tempTargetDest1 = temp2;\r\n\t\tlet tempTarget2 = null;\r\n\t\tlet tempTargetDest2 = null;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp3;\r\n\t\t\ttempTargetDest2 = temp4;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tlet closestDistanceOtherTriIndex = null;\r\n\t\ttempMatrix.copy( geometryToBvh ).invert();\r\n\t\tobb2.matrix.copy( tempMatrix );\r\n\t\tthis.shapecast(\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\r\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\r\n\t\tif ( closestDistance === Infinity ) return null;\r\n\r\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\r\n\t\telse target1.point.copy( tempTargetDest1 );\r\n\t\ttarget1.distance = closestDistance,\r\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\r\n\t\t\telse target2.point.copy( tempTargetDest2 );\r\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\r\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\r\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\r\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\r\n\r\n\t\t}\r\n\r\n\t\treturn target1;\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\ttemp1.copy( temp );\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\tif ( closestDistanceSq === Infinity ) return null;\r\n\r\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\r\n\r\n\t\tif ( ! target.point ) target.point = temp1.clone();\r\n\t\telse target.point.copy( temp1 );\r\n\t\ttarget.distance = closestDistance,\r\n\t\ttarget.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Deprecation\r\nconst originalRaycast = MeshBVH.prototype.raycast;\r\nMeshBVH.prototype.raycast = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray, intersects,\r\n\t\t] = args;\r\n\r\n\t\tconst results = originalRaycast.call( this, ray, mesh.material );\r\n\t\tresults.forEach( hit => {\r\n\r\n\t\t\thit = convertRaycastIntersect( hit, mesh, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn intersects;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycast.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRaycastFirst = MeshBVH.prototype.raycastFirst;\r\nMeshBVH.prototype.raycastFirst = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray,\r\n\t\t] = args;\r\n\r\n\t\treturn convertRaycastIntersect( originalRaycastFirst.call( this, ray, mesh.material ), mesh, raycaster );\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycastFirst.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\r\nMeshBVH.prototype.closestPointToPoint = function ( ...args ) {\r\n\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.' );\r\n\r\n\t\targs.unshift();\r\n\r\n\t\tconst target = args[ 1 ];\r\n\t\tconst result = {};\r\n\t\targs[ 1 ] = result;\r\n\r\n\t\toriginalClosestPointToPoint.apply( this, args );\r\n\r\n\t\tif ( target ) {\r\n\r\n\t\t\ttarget.copy( result.point );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToPoint.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\r\nMeshBVH.prototype.closestPointToGeometry = function ( ...args ) {\r\n\r\n\tconst target1 = args[ 2 ];\r\n\tconst target2 = args[ 3 ];\r\n\tif ( target1 && target1.isVector3 || target2 && target2.isVector3 ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst result1 = {};\r\n\t\tconst result2 = {};\r\n\t\tconst geometryToBvh = args[ 1 ];\r\n\t\targs[ 2 ] = result1;\r\n\t\targs[ 3 ] = result2;\r\n\r\n\t\toriginalClosestPointToGeometry.apply( this, args );\r\n\r\n\t\tif ( target1 ) {\r\n\r\n\t\t\ttarget1.copy( result1.point );\r\n\r\n\t\t}\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttarget2.copy( result2.point ).applyMatrix4( geometryToBvh );\r\n\r\n\t\t}\r\n\r\n\t\treturn result1.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToGeometry.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRefit = MeshBVH.prototype.refit;\r\nMeshBVH.prototype.refit = function ( ...args ) {\r\n\r\n\tconst nodeIndices = args[ 0 ];\r\n\tconst terminationIndices = args[ 1 ];\r\n\tif ( terminationIndices && ( terminationIndices instanceof Set || Array.isArray( terminationIndices ) ) ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst newNodeIndices = new Set();\r\n\t\tterminationIndices.forEach( v => newNodeIndices.add( v ) );\r\n\t\tif ( nodeIndices ) {\r\n\r\n\t\t\tnodeIndices.forEach( v => newNodeIndices.add( v ) );\r\n\r\n\t\t}\r\n\r\n\t\toriginalRefit.call( this, newNodeIndices );\r\n\r\n\t} else {\r\n\r\n\t\toriginalRefit.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\n[\r\n\t'intersectsGeometry',\r\n\t'shapecast',\r\n\t'intersectsBox',\r\n\t'intersectsSphere',\r\n].forEach( name => {\r\n\r\n\tconst originalFunc = MeshBVH.prototype[ name ];\r\n\tMeshBVH.prototype[ name ] = function ( ...args ) {\r\n\r\n\t\tif ( args[ 0 ] === null || args[ 0 ].isMesh ) {\r\n\r\n\t\t\targs.shift();\r\n\t\t\tconsole.warn( `MeshBVH: The function signature for \"${ name }\" has changed and no longer takes Mesh. See docs for new signature.` );\r\n\r\n\t\t}\r\n\r\n\t\treturn originalFunc.apply( this, args );\r\n\r\n\t};\r\n\r\n} );\r\n","import { Ray, Matrix4, Mesh } from 'three';\r\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\r\nimport { MeshBVH } from '../core/MeshBVH.js';\r\n\r\nconst ray = /* @__PURE__ */ new Ray();\r\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\r\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\r\n\r\nexport function acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\tconst bvh = this.geometry.boundsTree;\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst hits = bvh.raycast( ray, this.material );\r\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\r\n\t\t\t\tif ( hit ) {\r\n\r\n\t\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nexport function disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n","import {\n\tWebGLRenderer,\n\tPerspectiveCamera,\n\tColor,\n\tScene,\n\tDirectionalLight,\n\tAmbientLight,\n\tsRGBEncoding,\n\tGroup,\n\tRaycaster,\n\tVector2,\n\tVector3,\n\tMesh,\n\tPlaneBufferGeometry,\n\tMeshStandardMaterial,\n\tPCFSoftShadowMap,\n\tBufferGeometry,\n\tMathUtils,\n} from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\nimport {\n\tSolver,\n\tLink,\n\tJoint,\n\tSOLVE_STATUS_NAMES,\n\tIKRootsHelper,\n\tsetUrdfFromIK,\n\turdfRobotToIKRoot,\n\tsetIKFromUrdf,\n\tGoal,\n\tDOF,\n\tSOLVE_STATUS,\n} from '../src/index.js';\nimport URDFLoader from 'urdf-loader';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';\nimport { acceleratedRaycast, computeBoundsTree, disposeBoundsTree } from 'three-mesh-bvh';\n\nMesh.prototype.raycast = acceleratedRaycast;\nBufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nBufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\nconst params = {\n\tsolve: true,\n\tdisplayMesh: true,\n\tdisplayIk: false,\n\tenableControls: true,\n\tterrainHeight: 0.35,\n\tsettleIterations: 10,\n};\n\nconst solverOptions = {\n\tmaxIterations: 10,\n\tdivergeThreshold: 0.05,\n\tstallThreshold: 1e-4,\n\ttranslationErrorClamp: 1,\n\trotationErrorClamp: 0.25,\n};\n\nlet gui, stats;\nlet outputContainer, renderer, scene, camera;\nlet driveGoals;\nlet controls, transformControls, targetObject;\nlet terrain, directionalLight;\nlet ikNeedsUpdate = true;\nconst mouse = new Vector2();\nconst tempVec = new Vector3();\nconst raycaster = new Raycaster();\nconst posArr = new Float64Array( 3 );\n\nlet urdfRoot, ikRoot, ikHelper, drawThroughIkHelper, solver;\ninit();\nrender();\n\nfunction init() {\n\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\toutputContainer = document.getElementById( 'output' );\n\n\t// init renderer\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.shadowMap.enabled = true;\n\trenderer.shadowMap.type = PCFSoftShadowMap;\n\trenderer.outputEncoding = sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\tcamera = new PerspectiveCamera( 50, window.innerWidth / window.innerHeight );\n\tcamera.position.set( 8, 8, 8 );\n\n\tscene = new Scene();\n\tscene.background = new Color( 0x1e161d );\n\n\t// init light / shadow camera\n\tdirectionalLight = new DirectionalLight();\n\tdirectionalLight.position.set( 1, 3, 2 );\n\tdirectionalLight.intensity = 0.75;\n\tdirectionalLight.castShadow = true;\n\tdirectionalLight.shadow.normalBias = 1e-4;\n\tdirectionalLight.shadow.mapSize.setScalar( 1024 );\n\n\tconst shadowCam = directionalLight.shadow.camera;\n\tshadowCam.top = shadowCam.right = 2;\n\tshadowCam.left = shadowCam.bottom = - 2;\n\tshadowCam.updateProjectionMatrix();\n\tscene.add( directionalLight, directionalLight.target );\n\n\tconst ambientLight = new AmbientLight( 0x1f1a1e, 1 );\n\tscene.add( ambientLight );\n\n\t// controls\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\ttransformControls = new TransformControls( camera, renderer.domElement );\n\ttransformControls.setSpace( 'local' );\n\tscene.add( transformControls );\n\n\ttransformControls.addEventListener( 'mouseDown', () => controls.enabled = false );\n\ttransformControls.addEventListener( 'mouseUp', () => controls.enabled = true );\n\n\t// urdf target\n\ttargetObject = new Group();\n\ttargetObject.position.set( 0, 0, 0 );\n\ttargetObject.rotation.set( Math.PI / 2, 0, 0 );\n\tscene.add( targetObject );\n\ttransformControls.attach( targetObject );\n\ttransformControls.addEventListener( 'objectChange', () => {\n\n\t\tikNeedsUpdate = true;\n\n\t} );\n\n\t// generate terrain\n\tconst dimension = 400;\n\tterrain = new Mesh( new PlaneBufferGeometry( 25, 25, dimension, dimension ), new MeshStandardMaterial() );\n\n\tconst posAttr = terrain.geometry.attributes.position;\n\tfor ( let x = 0; x <= dimension + 1; x ++ ) {\n\n\t\tfor ( let y = 0; y <= dimension + 1; y ++ ) {\n\n\t\t\tconst i = dimension * x + y;\n\t\t\tconst xv = posAttr.getX( i ) * 1.5;\n\t\t\tconst yv = posAttr.getY( i ) * 1.5;\n\n\t\t\tposAttr.setZ( i, Math.min( Math.abs( Math.sin( yv ) ), Math.abs( Math.sin( xv ) ) ) );\n\n\t\t}\n\n\t}\n\n\tterrain.rotation.set( - Math.PI / 2, 0, 0 );\n\tterrain.geometry.computeVertexNormals();\n\tterrain.receiveShadow = true;\n\tterrain.geometry.computeBoundsTree();\n\tscene.add( terrain );\n\n\t// init gui\n\tgui = new GUI();\n\tgui.add( params, 'enableControls' );\n\tgui.add( params, 'solve' );\n\tgui.add( params, 'displayMesh' );\n\tgui.add( params, 'displayIk' );\n\tgui.add( params, 'settleIterations' ).min( 1 ).max( 20 ).step( 1 ).onChange( () => ikNeedsUpdate = true );\n\tgui.add( params, 'terrainHeight', 0.05, 0.7 ).onChange( () => ikNeedsUpdate = true );\n\n\t// load model\n\tconst loader = new URDFLoader();\n\tloader.fetchOptions = {\n\t\tmode: 'cors',\n\t};\n\tloader.loadMeshCb = ( path, manager, done ) => {\n\n\t\tif ( /\\.glb$/.test( path ) || /\\.gltf$/.test( path ) ) {\n\n\t\t\tnew GLTFLoader( manager ).load( path, res => {\n\n\t\t\t\tres.scene.traverse( c => {\n\n\t\t\t\t\tc.castShadow = true;\n\t\t\t\t\tc.receiveShadow = true;\n\t\t\t\t\tif ( c.geometry && ! c.geometry.attributes.normals ) {\n\n\t\t\t\t\t\tc.geometry.computeVertexNormals();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tdone( res.scene );\n\n\t\t\t} );\n\n\t\t} else if ( /\\.stl$/.test( path ) ) {\n\n\t\t\tnew STLLoader( manager ).load( path, res => {\n\n\t\t\t\tconst mesh = new Mesh( res );\n\t\t\t\tmesh.castShadow = true;\n\t\t\t\tmesh.receiveShadow = true;\n\t\t\t\tdone( mesh );\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n\tloader\n\t\t.loadAsync( 'https://raw.githubusercontent.com/gkjohnson/m2020-urdf-models/main/rover/m2020.urdf' )\n\t\t.then( result => {\n\n\t\t\tresult.traverse( c => {\n\n\t\t\t\tif ( c.jointType === 'floating') {\n\n\t\t\t\t\tc.jointType = 'fixed';\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\turdfRoot = result;\n\t\t\tikRoot = urdfRobotToIKRoot( urdfRoot, true );\n\n\t\t\tconst differential = ikRoot.find( c => c.name === 'CENTER_DIFFERENTIAL' ).child;\n\t\t\tdifferential.removeChild( differential.children[ 0 ] );\n\n\t\t\t// left connector\n\t\t\tconst leftDifferential = ikRoot.find( c => c.name === 'LEFT_DIFFERENTIAL' ).child;\n\t\t\tconst leftJoint = new Joint();\n\t\t\tdifferential.addChild( leftJoint );\n\n\t\t\tconst leftArm = new Link();\n\t\t\tleftArm.setPosition( 0, - 0.7, 0 );\n\t\t\tleftJoint.addChild( leftArm );\n\n\t\t\tconst leftZ = new Joint();\n\t\t\tleftZ.setDoF( DOF.EZ );\n\t\t\tleftArm.addChild( leftZ );\n\n\t\t\tconst leftZLink = new Link();\n\t\t\tleftZLink.setPosition( 0, 0, 0 );\n\t\t\tleftZ.addChild( leftZLink );\n\n\t\t\tconst leftY = new Joint();\n\t\t\tleftY.setDoF( DOF.EY );\n\t\t\tleftZLink.addChild( leftY );\n\n\t\t\tconst leftConnector = new Link();\n\t\t\tleftDifferential.getWorldPosition( leftConnector.position );\n\t\t\tleftConnector.setMatrixNeedsUpdate();\n\t\t\tleftY.attachChild( leftConnector );\n\t\t\tleftConnector.position[ 1 ] = 0;\n\t\t\tleftConnector.position[ 2 ] = 0;\n\t\t\tleftConnector.setMatrixNeedsUpdate();\n\n\t\t\tconst leftDiffConnectorJoint = new Joint();\n\t\t\tleftDifferential.addChild( leftDiffConnectorJoint );\n\n\t\t\tconst leftDifferentialConnector = new Link();\n\t\t\tleftConnector.getWorldPosition( leftDifferentialConnector.position );\n\t\t\tleftConnector.getWorldQuaternion( leftDifferentialConnector.quaternion );\n\t\t\tleftDifferentialConnector.setMatrixNeedsUpdate();\n\t\t\tleftDiffConnectorJoint.attachChild( leftDifferentialConnector );\n\n\t\t\tconst leftDiffGoal = new Goal();\n\t\t\tleftDiffGoal.setFreeDoF( DOF.EX, DOF.EY, DOF.EZ );\n\t\t\tleftDifferentialConnector.addChild( leftDiffGoal );\n\t\t\tleftDiffGoal.makeClosure( leftConnector );\n\n\t\t\t// right connector\n\t\t\tconst rightDifferential = ikRoot.find( c => c.name === 'RIGHT_DIFFERENTIAL' ).child;\n\t\t\tconst rightJoint = new Joint();\n\t\t\tdifferential.addChild( rightJoint );\n\n\t\t\tconst rightArm = new Link();\n\t\t\trightArm.setPosition( 0, 0.7, 0 );\n\t\t\trightJoint.addChild( rightArm );\n\n\t\t\tconst rightZ = new Joint();\n\t\t\trightZ.setDoF( DOF.EZ );\n\t\t\trightArm.addChild( rightZ );\n\n\t\t\tconst rightZLink = new Link();\n\t\t\trightZLink.setPosition( 0, 0, 0 );\n\t\t\trightZ.addChild( rightZLink );\n\n\t\t\tconst rightY = new Joint();\n\t\t\trightY.setDoF( DOF.EY );\n\t\t\trightZLink.addChild( rightY );\n\n\t\t\tconst rightConnector = new Link();\n\t\t\trightDifferential.getWorldPosition( rightConnector.position );\n\t\t\trightConnector.setMatrixNeedsUpdate();\n\t\t\trightY.attachChild( rightConnector );\n\t\t\trightConnector.position[ 1 ] = 0;\n\t\t\trightConnector.position[ 2 ] = 0;\n\t\t\trightConnector.setMatrixNeedsUpdate();\n\n\t\t\tconst rightDiffConnectorJoint = new Joint();\n\t\t\trightDifferential.addChild( rightDiffConnectorJoint );\n\n\t\t\tconst rightDifferentialConnector = new Link();\n\t\t\trightConnector.getWorldPosition( rightDifferentialConnector.position );\n\t\t\trightConnector.getWorldQuaternion( rightDifferentialConnector.quaternion );\n\t\t\trightDifferentialConnector.setMatrixNeedsUpdate();\n\t\t\trightDiffConnectorJoint.attachChild( rightDifferentialConnector );\n\n\t\t\tconst rightDiffGoal = new Goal();\n\t\t\trightDiffGoal.setFreeDoF( DOF.EX, DOF.EY, DOF.EZ );\n\t\t\trightDifferentialConnector.addChild( rightDiffGoal );\n\t\t\trightDiffGoal.makeClosure( rightConnector );\n\n\t\t\t// generate ik visualization\n\t\t\tikHelper = new IKRootsHelper( [ ikRoot ] );\n\t\t\tikHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\t\tikHelper.color.set( 0xe91e63 ).convertSRGBToLinear();\n\t\t\tikHelper.setColor( ikHelper.color );\n\n\t\t\tdrawThroughIkHelper = new IKRootsHelper( [ ikRoot ] );\n\t\t\tdrawThroughIkHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\t\tdrawThroughIkHelper.color.set( 0xe91e63 ).convertSRGBToLinear();\n\t\t\tdrawThroughIkHelper.setColor( drawThroughIkHelper.color );\n\t\t\tdrawThroughIkHelper.setDrawThrough( true );\n\n\t\t\turdfRoot.rotation.set( Math.PI / 2, 0, 0 );\n\t\t\tsetIKFromUrdf( ikRoot, urdfRoot );\n\n\t\t\t// initialize wheel goals\n\t\t\tdriveGoals = [\n\t\t\t\t'LR_DRIVE',\n\t\t\t\t'LM_DRIVE',\n\t\t\t\t'LF_DRIVE',\n\t\t\t\t'RR_DRIVE',\n\t\t\t\t'RM_DRIVE',\n\t\t\t\t'RF_DRIVE',\n\t\t\t].map( name => {\n\n\t\t\t\tconst goal = new Goal();\n\t\t\t\tgoal.setGoalDoF( DOF.X, DOF.Y, DOF.Z );\n\t\t\t\tikRoot.traverse( c => {\n\n\t\t\t\t\tif ( c.name === name ) {\n\n\t\t\t\t\t\tconst link = c.child;\n\t\t\t\t\t\tlink.getWorldPosition( goal.position );\n\t\t\t\t\t\tgoal.setMatrixWorldNeedsUpdate();\n\t\t\t\t\t\tgoal.makeClosure( link );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\treturn goal;\n\n\t\t\t} );\n\n\t\t\t// set the arm angles\n\t\t\tikRoot.traverse( c => {\n\n\t\t\t\tswitch ( c.name ) {\n\n\t\t\t\t\tcase 'JOINT1_ENC':\n\t\t\t\t\t\tc.setTargetValues( 90 * MathUtils.DEG2RAD );\n\t\t\t\t\t\tc.targetSet = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'JOINT2_ENC':\n\t\t\t\t\t\tc.setTargetValues( - 18 * MathUtils.DEG2RAD );\n\t\t\t\t\t\tc.targetSet = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'JOINT3_ENC':\n\t\t\t\t\t\tc.setTargetValues( - 160 * MathUtils.DEG2RAD );\n\t\t\t\t\t\tc.targetSet = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'JOINT4_ENC':\n\t\t\t\t\t\tc.setTargetValues( 178 * MathUtils.DEG2RAD );\n\t\t\t\t\t\tc.targetSet = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'JOINT5_ENC':\n\t\t\t\t\t\tc.setTargetValues( 90 * MathUtils.DEG2RAD );\n\t\t\t\t\t\tc.targetSet = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RSM_AZ_ENC':\n\t\t\t\t\t\tc.setTargetValues( 180 * MathUtils.DEG2RAD );\n\t\t\t\t\t\tc.targetSet = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RSM_EL_ENC':\n\t\t\t\t\t\tc.setTargetValues( 90 * MathUtils.DEG2RAD );\n\t\t\t\t\t\tc.targetSet = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tsolver = new Solver( [ ikRoot, ...driveGoals ] );\n\n\t\t\tscene.add( urdfRoot, ikHelper, drawThroughIkHelper );\n\n\t\t} );\n\n\twindow.addEventListener( 'resize', () => {\n\n\t\tconst w = window.innerWidth;\n\t\tconst h = window.innerHeight;\n\t\tconst aspect = w / h;\n\n\t\trenderer.setSize( w, h );\n\n\t\tcamera.aspect = aspect;\n\t\tcamera.updateProjectionMatrix();\n\n\t\tif ( ikHelper ) {\n\n\t\t\tikHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\t\tdrawThroughIkHelper.setResolution( window.innerWidth, window.innerHeight );\n\n\t\t}\n\n\t} );\n\n\twindow.addEventListener( 'keydown', e => {\n\n\t\tswitch ( e.key ) {\n\n\t\t\tcase 'w':\n\t\t\t\ttransformControls.setMode( 'translate' );\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\ttransformControls.setMode( 'rotate' );\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\ttransformControls.setSpace( transformControls.space === 'local' ? 'world' : 'local' );\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\t\t\t\tcontrols.update();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointerdown', e => {\n\n\t\tmouse.x = e.clientX;\n\t\tmouse.y = e.clientY;\n\n\t} );\n\n}\n\nfunction updateIk() {\n\n\t// update the ik root from the draggable root\n\tikRoot.setPosition(\n\t\ttargetObject.position.x,\n\t\tikRoot.position[ 1 ],\n\t\ttargetObject.position.z,\n\t);\n\n\tikRoot.setQuaternion(\n\t\ttargetObject.quaternion.x,\n\t\ttargetObject.quaternion.y,\n\t\ttargetObject.quaternion.z,\n\t\ttargetObject.quaternion.w,\n\t);\n\n\tikRoot.traverse( c => {\n\n\t\tif ( c.isJoint ) {\n\n\t\t\tc.dofValues.fill( 0 );\n\t\t\tc.setMatrixDoFNeedsUpdate();\n\n\t\t}\n\n\t} );\n\n\tlet solveOutput = '';\n\tlet totalTime = 0;\n\n\tfor ( let i = 0; i < params.settleIterations; i ++ ) {\n\n\t\t// udpate drive goals from the new location\n\t\tikRoot.updateMatrixWorld( true );\n\n\t\tdriveGoals.forEach( ( goal, i ) => {\n\n\t\t\tconst link = goal.child;\n\t\t\tlink.getWorldPosition( posArr );\n\n\t\t\traycaster.ray.origin.set( posArr[ 0 ], 3, posArr[ 2 ] );\n\t\t\traycaster.ray.direction.set( 0, - 1, 0 );\n\t\t\traycaster.firstHitOnly = true;\n\n\t\t\tlet height = 0;\n\t\t\tconst res = raycaster.intersectObject( terrain, true );\n\t\t\tif ( res.length ) {\n\n\t\t\t\theight = res[ 0 ].point.y + 0.25;\n\n\t\t\t}\n\n\t\t\tgoal.setPosition( posArr[ 0 ], height, posArr[ 2 ] );\n\n\t\t} );\n\n\t\t// update options\n\t\tObject.assign( solver, solverOptions );\n\n\t\t// update store results\n\t\tconst startTime = window.performance.now();\n\t\tconst results = solver.solve();\n\t\tconst delta = window.performance.now() - startTime;\n\t\ttotalTime += delta;\n\n\t\tsolveOutput += delta.toFixed( 2 ) + 'ms ' + SOLVE_STATUS_NAMES[ results[ 0 ] ] + '\\n';\n\n\t\tconst isConverged = results.filter( r => r === SOLVE_STATUS.CONVERGED ).length === results.length;\n\t\tconst isAllDiverged = results.filter( r => r === SOLVE_STATUS.DIVERGED ).length === results.length;\n\t\tif ( isConverged || isAllDiverged ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// update output\n\tsolveOutput = solveOutput + '\\n' + 'Total: ' + totalTime.toFixed( 2 ) + 'ms';\n\n\toutputContainer.textContent = solveOutput;\n\n\tsetUrdfFromIK( urdfRoot, ikRoot );\n\n}\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\tterrain.scale.z = params.terrainHeight;\n\n\tif ( urdfRoot ) {\n\n\t\tif ( ikNeedsUpdate && params.solve ) {\n\n\t\t\tupdateIk();\n\t\t\tikNeedsUpdate = false;\n\n\t\t} else if ( ! params.solve ) {\n\n\t\t\tikRoot.setPosition(\n\t\t\t\ttargetObject.position.x,\n\t\t\t\ttargetObject.position.y,\n\t\t\t\ttargetObject.position.z,\n\t\t\t);\n\t\t\tikRoot.setQuaternion(\n\t\t\t\ttargetObject.quaternion.x,\n\t\t\t\ttargetObject.quaternion.y,\n\t\t\t\ttargetObject.quaternion.z,\n\t\t\t\ttargetObject.quaternion.w,\n\t\t\t);\n\t\t\tsetUrdfFromIK( urdfRoot, ikRoot );\n\n\t\t}\n\n\t}\n\n\tif ( urdfRoot ) {\n\n\t\turdfRoot.visible = params.displayMesh;\n\t\tikHelper.visible = params.displayIk;\n\t\tdrawThroughIkHelper.visible = params.displayIk;\n\n\t}\n\n\tif ( ikRoot && ! transformControls.dragging ) {\n\n\t\ttargetObject.position.set( ...ikRoot.position );\n\t\ttargetObject.quaternion.set( ...ikRoot.quaternion );\n\n\t}\n\n\tif ( urdfRoot ) {\n\n\t\ttempVec.subVectors( directionalLight.position, directionalLight.target.position );\n\t\tdirectionalLight.target.position.copy( urdfRoot.position );\n\t\tdirectionalLight.position.copy( urdfRoot.position ).add( tempVec );\n\n\t}\n\n\ttransformControls.visible = params.enableControls;\n\ttransformControls.enabled = params.enableControls;\n\n\trenderer.render( scene, camera );\n\tstats.update();\n\n}\n\n"],"names":["$5664c169f49816c4$var$vA","Vector3","$5664c169f49816c4$var$vB","$ilwiq","$5664c169f49816c4$var$vC","$5664c169f49816c4$var$uvA","Vector2","$5664c169f49816c4$var$uvB","$5664c169f49816c4$var$uvC","$5664c169f49816c4$var$intersectionPoint","$5664c169f49816c4$var$checkBufferGeometryIntersection","ray","position","uv","a","b","c","side","fromBufferAttribute","intersection","pA","pB","pC","point","intersect","BackSide","intersectTriangle","DoubleSide","distance","origin","distanceTo","clone","$5664c169f49816c4$var$checkIntersection","Triangle","getUV","face","normal","materialIndex","getNormal","faceIndex","$5664c169f49816c4$export$1a557053019a130b","geo","tri","intersections","triOffset","index","getX","attributes","push","$9c2d3902c622414b$export$adb106eed99e8cd8","hit","object","raycaster","applyMatrix4","matrixWorld","near","far","$78926744db4a8a3e$export$859129fb5c8f4dc1","Math","pow","$096668f03fbb5645$export$6f473cc5f89b0a1c","$a9f34d1ac25848aa$export$40b9a5e446bf11e0","nodeIndex32","array","target","min","x","y","z","max","$a9f34d1ac25848aa$export$dcdc414399b99746","bounds","splitDimIdx","splitDist","Infinity","i","dist","$a9f34d1ac25848aa$export$14b050a767b4a3a7","source","set","$a9f34d1ac25848aa$export$a8a7063dce01a911","aVal","bVal","d","d3","$a9f34d1ac25848aa$export$c989e53c4b24c2f5","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","$a9f34d1ac25848aa$export$dbf4320364dc239e","d0","d1","d2","$726e7ff6aee710f1$var$getBounds","offset","count","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","$726e7ff6aee710f1$var$binsSort","candidate","$726e7ff6aee710f1$var$sahBins","Array","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","$726e7ff6aee710f1$var$leftBounds","$726e7ff6aee710f1$export$9896244d8c99a4d0","options","triggerProgress","trianglesProcessed","onProgress","totalTriangles","splitNode","node","centroidBoundingData","depth","reachedMaxDepth","maxDepth","verbose","console","warn","maxLeafTris","split","nodeBoundingData","strategy","axis","pos","avg","$726e7ff6aee710f1$var$getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","$726e7ff6aee710f1$var$BIN_COUNT","truncatedBins","length","bin","sort","splitCount","bi","splice","c1","center","bi1","leftCount","rightCount","leftBounds","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","i1","nextBin","i2","binCount","$726e7ff6aee710f1$var$getOptimalSplit","boundingData","splitOffset","left","right","axisOffset","t0","t1","t2","$726e7ff6aee710f1$var$partition","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","vertexCount","BufferConstructor","useSharedArrayBuffer","SharedArrayBuffer","ArrayBuffer","Uint32Array","Uint16Array","setIndex","BufferAttribute","$726e7ff6aee710f1$var$ensureIndex","fullBounds","posAttr","posArr","triCount","bufferOffset","stride","isInterleavedBufferAttribute","data","tri3","tri6","ai","ci","el","halfExtents","el2","abs","$726e7ff6aee710f1$var$computeTriangleBounds","roots","ranges","groups","rangeBoundaries","Set","group","add","start","sortedBoundaries","from","values","$726e7ff6aee710f1$var$getRootIndexRanges","range","root","$726e7ff6aee710f1$var$getCentroidBounds","$20d478469c10be0c$export$f758e41ecdcd8e69","this","setFromPointsField","points","field","l","val","setFromPoints","p","dot","isSeparated","other","prototype","setFromBox","box","boxMin","boxMax","cacheSatBounds","$afac8e64b68760a8$export$479eef7c8f1b846c","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","denom","$afac8e64b68760a8$export$b09f296caca7547a","paramResult","temp1","temp2","target1","target2","at","closestPointToPoint","p2","closestPoint","closestPoint2","distanceToSquared","copy","$afac8e64b68760a8$export$eed3a6606b3adc41","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","plane","getPlane","distanceToPoint","pp","projectPoint","containsPoint","$681270c6f2e9ebff$export$a37f7ec1c23dfacf","args","super","isExtendedTriangle","satAxes","satBounds","Sphere","needsUpdate","intersectsSphere","update","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","tempDir","edge1","edge2","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","sa2","crossVectors","points1","found1","count1","p1","delta","intersectLine","points2","found2","count2","i3","tmp","s1","e1","s2","e2","separated1","separated2","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","i4","f11","f12","f21","f22","$f74d70f31e44d1f9$export$4ccecd8ac6ee0e58","Box3","isOrientedBox","matrix","Matrix4","invMatrix","alignedSatBounds","$a17a0e7ef0b826e6$export$32f7fa781964ae30","ta","tb","tc","i0","getY","getZ","$a17a0e7ef0b826e6$export$be1391b7aa79c0f6","geometry","intersectsTriangleFunc","contained","v","minVec","pi","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","nextIndex","nextIndex2","index2","f1","f2","f3","$0f9e1864656e7fae$export$bf300c504651112a","getNewPrimitive","_getNewPrimitive","_primitives","getPrimitive","primitives","pop","releasePrimitive","primitive","$6429d316c174c83b$export$bc7cbaf27fbe938e","n16","uint16Array","$6429d316c174c83b$export$3231e969238304f3","n32","uint32Array","$6429d316c174c83b$export$d61684373eacdf61","$6429d316c174c83b$export$7a68bc00425859d","$6429d316c174c83b$export$4f44f52d9f75fa31","$41be8c2e4f32d781$var$boundingBox","$41be8c2e4f32d781$var$boxIntersection","$41be8c2e4f32d781$var$xyzFields","$41be8c2e4f32d781$export$630e89aab3ddc1d6","intersects","nodeIndex16","float32Array","$41be8c2e4f32d781$var$_float32Array","$41be8c2e4f32d781$var$_uint16Array","$41be8c2e4f32d781$var$_uint32Array","$9c2d3902c622414b$export$6f0a8fc5d2775a51","leftIndex","$41be8c2e4f32d781$var$intersectRay","rightIndex","$41be8c2e4f32d781$export$1fa457bc72ef1a2a","res","$9c2d3902c622414b$export$4331f2604b0bca4","$6429d316c174c83b$export$b43717b3ca95505","xyzAxis","leftToRight","direction","c2","c1Result","c2Result","$41be8c2e4f32d781$export$963c78622ed2c172","_box1","_box2","boxStack","boxPool","shapecastTraverse","nodeIndex321","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","getLeftOffset","getRightEndOffset","nodeIndex161","uint16Array1","uint32Array1","score1","score2","box1","box2","temp","c1Intersection","c1StopTraversal","c2Intersection","c2StopTraversal","$41be8c2e4f32d781$export$b2f96b0abaf94e0a","triangle2","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","boundingBox","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","shapecast","intersectsBounds","intersectBox","$41be8c2e4f32d781$var$bufferStack","$41be8c2e4f32d781$var$_prevBuffer","$41be8c2e4f32d781$export$8e35cea4592af4e6","buffer","$41be8c2e4f32d781$export$abb0b37bc9255c0e","$4eb4044e12c26831$var$SKIP_GENERATION","Symbol","$4eb4044e12c26831$var$aabb","$4eb4044e12c26831$var$aabb2","$4eb4044e12c26831$var$tempMatrix","$4eb4044e12c26831$var$obb","$4eb4044e12c26831$var$obb2","$4eb4044e12c26831$var$temp","$4eb4044e12c26831$var$temp1","$4eb4044e12c26831$var$temp2","$4eb4044e12c26831$var$temp3","$4eb4044e12c26831$var$temp4","$4eb4044e12c26831$var$tempBox","$4eb4044e12c26831$var$trianglePool","$4eb4044e12c26831$export$9d614b3bc2c4eacf","bvh","isBufferGeometry","serialize","arguments","cloneBuffers","undefined","rootData","_roots","indexAttribute","getIndex","slice","deserialize","newIndex","Error","Object","assign","setBoundingBox","packedRoots","countNodes","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","$726e7ff6aee710f1$export$e63bca57f220b8e3","getBoundingBox","refit","nodeIndices","isArray","indexArr","byteOffset1","_traverse","byteLength","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","$78926744db4a8a3e$export$a08e7d18fbc53be5","raycast","materialOrSide","FrontSide","isMaterial","isArrayMaterial","materialSide","startCount","j","jl","raycastFirst","closestResult","intersectsGeometry","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","boundsTraverseOrder","intersectsRange","originalIntersectsRange","nodeIndex","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","iterateOverDoubleTriangles","offset1","offset2","depth1","index1","depth2","originalIntersectsRanges","nodeIndex1","nodeIndex2","boxToMesh","closestPointToGeometry","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","forEach","union","$4eb4044e12c26831$var$originalRaycast","isMesh","mesh","call","material","apply","$4eb4044e12c26831$var$originalRaycastFirst","$4eb4044e12c26831$var$originalClosestPointToPoint","unshift","$4eb4044e12c26831$var$originalClosestPointToGeometry","isVector3","result1","result2","$4eb4044e12c26831$var$originalRefit","terminationIndices","newNodeIndices","name","originalFunc","shift","$8e95af8c076e330d$var$ray","Ray","$8e95af8c076e330d$var$tmpInverseMatrix","$8e95af8c076e330d$var$origMeshRaycastFunc","Mesh","firstHitOnly","hits","BufferGeometry","computeBoundsTree","disposeBoundsTree","$4e26dd46ec2653bc$var$params","solve","displayMesh","displayIk","enableControls","terrainHeight","settleIterations","$4e26dd46ec2653bc$var$solverOptions","maxIterations","divergeThreshold","stallThreshold","translationErrorClamp","rotationErrorClamp","$4e26dd46ec2653bc$var$gui","$4e26dd46ec2653bc$var$stats","$4e26dd46ec2653bc$var$outputContainer","$4e26dd46ec2653bc$var$renderer","$4e26dd46ec2653bc$var$scene","$4e26dd46ec2653bc$var$camera","$4e26dd46ec2653bc$var$driveGoals","$4e26dd46ec2653bc$var$controls","$4e26dd46ec2653bc$var$transformControls","$4e26dd46ec2653bc$var$targetObject","$4e26dd46ec2653bc$var$terrain","$4e26dd46ec2653bc$var$directionalLight","$4e26dd46ec2653bc$var$ikNeedsUpdate","$4e26dd46ec2653bc$var$mouse","$4e26dd46ec2653bc$var$tempVec","$4e26dd46ec2653bc$var$raycaster","Raycaster","$4e26dd46ec2653bc$var$posArr","Float64Array","$4e26dd46ec2653bc$var$urdfRoot","$4e26dd46ec2653bc$var$ikRoot","$4e26dd46ec2653bc$var$ikHelper","$4e26dd46ec2653bc$var$drawThroughIkHelper","$4e26dd46ec2653bc$var$solver","$7MGRS","default","document","body","appendChild","dom","getElementById","WebGLRenderer","antialias","setPixelRatio","window","devicePixelRatio","setSize","innerWidth","innerHeight","shadowMap","enabled","type","PCFSoftShadowMap","outputEncoding","sRGBEncoding","domElement","PerspectiveCamera","Scene","background","Color","DirectionalLight","intensity","castShadow","shadow","normalBias","mapSize","setScalar","shadowCam","camera","top","bottom","updateProjectionMatrix","ambientLight","AmbientLight","$5Rd1x","OrbitControls","$fUhpq","TransformControls","setSpace","addEventListener","Group","rotation","PI","attach","dimension","PlaneBufferGeometry","MeshStandardMaterial","xv","yv","setZ","sin","computeVertexNormals","receiveShadow","$jiuw3","GUI","step","onChange","loader","$8C12l","fetchOptions","mode","loadMeshCb","path","manager","done","test","$7lx9d","GLTFLoader","load","scene","normals","$Q6arU","STLLoader","loadAsync","then","jointType","$4CEV9","urdfRobotToIKRoot","differential","find","child","removeChild","children","leftDifferential","leftJoint","Joint","addChild","leftArm","Link","setPosition","leftZ","setDoF","DOF","EZ","leftZLink","leftY","EY","leftConnector","getWorldPosition","setMatrixNeedsUpdate","attachChild","leftDiffConnectorJoint","leftDifferentialConnector","getWorldQuaternion","quaternion","leftDiffGoal","Goal","setFreeDoF","EX","makeClosure","rightDifferential","rightJoint","rightArm","rightZ","rightZLink","rightY","rightConnector","rightDiffConnectorJoint","rightDifferentialConnector","rightDiffGoal","IKRootsHelper","setResolution","color","convertSRGBToLinear","setColor","setDrawThrough","setIKFromUrdf","goal","setGoalDoF","X","Y","Z","link","setMatrixWorldNeedsUpdate","setTargetValues","MathUtils","DEG2RAD","targetSet","Solver","w","h","aspect","e","key","setMode","space","clientX","clientY","$4e26dd46ec2653bc$var$init","$4e26dd46ec2653bc$var$render","requestAnimationFrame","scale","setQuaternion","isJoint","dofValues","setMatrixDoFNeedsUpdate","solveOutput","totalTime","updateMatrixWorld","height","intersectObject","startTime","performance","now","results","toFixed","SOLVE_STATUS_NAMES","isConverged","filter","r","SOLVE_STATUS","CONVERGED","isAllDiverged","DIVERGED","textContent","setUrdfFromIK","$4e26dd46ec2653bc$var$updateIk","visible","dragging","render"],"version":3,"file":"settling.efa3b5cd.js.map"}