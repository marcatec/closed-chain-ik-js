{"mappings":"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","sources":["node_modules/urdf-loader/src/URDFLoader.js","node_modules/three/examples/jsm/loaders/STLLoader.js","node_modules/three/examples/jsm/loaders/ColladaLoader.js","node_modules/three/examples/jsm/loaders/TGALoader.js","node_modules/urdf-loader/src/URDFClasses.js"],"sourcesContent":["import * as THREE from 'three';\r\nimport { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';\r\nimport { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader.js';\r\nimport { URDFRobot, URDFJoint, URDFLink, URDFCollider, URDFVisual, URDFMimicJoint } from './URDFClasses.js';\r\n\r\n/*\r\nReference coordinate frames for THREE.js and ROS.\r\nBoth coordinate systems are right handed so the URDF is instantiated without\r\nframe transforms. The resulting model can be rotated to rectify the proper up,\r\nright, and forward directions\r\n\r\nTHREE.js\r\n   Y\r\n   |\r\n   |\r\n   .-----X\r\n \r\nZ\r\n\r\nROS URDf\r\n       Z\r\n       |   X\r\n       | \r\n Y-----.\r\n\r\n*/\r\n\r\nconst tempQuaternion = new THREE.Quaternion();\r\nconst tempEuler = new THREE.Euler();\r\n\r\n// take a vector \"x y z\" and process it into\r\n// an array [x, y, z]\r\nfunction processTuple(val) {\r\n\r\n    if (!val) return [0, 0, 0];\r\n    return val.trim().split(/\\s+/g).map(num => parseFloat(num));\r\n\r\n}\r\n\r\n// applies a rotation a threejs object in URDF order\r\nfunction applyRotation(obj, rpy, additive = false) {\r\n\r\n    // if additive is true the rotation is applied in\r\n    // addition to the existing rotation\r\n    if (!additive) obj.rotation.set(0, 0, 0);\r\n\r\n    tempEuler.set(rpy[0], rpy[1], rpy[2], 'ZYX');\r\n    tempQuaternion.setFromEuler(tempEuler);\r\n    tempQuaternion.multiply(obj.quaternion);\r\n    obj.quaternion.copy(tempQuaternion);\r\n\r\n}\r\n\r\n/* URDFLoader Class */\r\n// Loads and reads a URDF file into a THREEjs Object3D format\r\nexport default\r\nclass URDFLoader {\r\n\r\n    constructor(manager) {\r\n\r\n        this.manager = manager || THREE.DefaultLoadingManager;\r\n        this.loadMeshCb = this.defaultMeshLoader.bind(this);\r\n        this.parseVisual = true;\r\n        this.parseCollision = false;\r\n        this.packages = '';\r\n        this.workingPath = '';\r\n        this.fetchOptions = {};\r\n\r\n    }\r\n\r\n    /* Public API */\r\n    loadAsync(urdf) {\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            this.load(urdf, resolve, null, reject);\r\n\r\n        });\r\n\r\n    }\r\n\r\n    // urdf:    The path to the URDF within the package OR absolute\r\n    // onComplete:      Callback that is passed the model once loaded\r\n    load(urdf, onComplete, onProgress, onError) {\r\n\r\n        // Check if a full URI is specified before\r\n        // prepending the package info\r\n        const manager = this.manager;\r\n        const workingPath = THREE.LoaderUtils.extractUrlBase(urdf);\r\n        const urdfPath = this.manager.resolveURL(urdf);\r\n\r\n        manager.itemStart(urdfPath);\r\n\r\n        fetch(urdfPath, this.fetchOptions)\r\n            .then(res => {\r\n\r\n                if (res.ok) {\r\n\r\n                    if (onProgress) {\r\n\r\n                        onProgress(null);\r\n\r\n                    }\r\n                    return res.text();\r\n\r\n                } else {\r\n\r\n                    throw new Error(`URDFLoader: Failed to load url '${ urdfPath }' with error code ${ res.status } : ${ res.statusText }.`);\r\n\r\n                }\r\n\r\n            })\r\n            .then(data => {\r\n\r\n                if (this.workingPath === '') {\r\n\r\n                    this.workingPath = workingPath;\r\n\r\n                }\r\n\r\n                const model = this.parse(data);\r\n                onComplete(model);\r\n                manager.itemEnd(urdfPath);\r\n\r\n            })\r\n            .catch(e => {\r\n\r\n                if (onError) {\r\n\r\n                    onError(e);\r\n\r\n                } else {\r\n\r\n                    console.error('URDFLoader: Error loading file.', e);\r\n\r\n                }\r\n                manager.itemError(urdfPath);\r\n                manager.itemEnd(urdfPath);\r\n\r\n            });\r\n\r\n    }\r\n\r\n    parse(content) {\r\n\r\n        const packages = this.packages;\r\n        const loadMeshCb = this.loadMeshCb;\r\n        const parseVisual = this.parseVisual;\r\n        const parseCollision = this.parseCollision;\r\n        const workingPath = this.workingPath;\r\n        const manager = this.manager;\r\n        const linkMap = {};\r\n        const jointMap = {};\r\n        const materialMap = {};\r\n\r\n        // Resolves the path of mesh files\r\n        function resolvePath(path) {\r\n\r\n            if (!/^package:\\/\\//.test(path)) {\r\n\r\n                return workingPath ? workingPath + path : path;\r\n\r\n            }\r\n\r\n            // Remove \"package://\" keyword and split meshPath at the first slash\r\n            const [targetPkg, relPath] = path.replace(/^package:\\/\\//, '').split(/\\/(.+)/);\r\n\r\n            if (typeof packages === 'string') {\r\n\r\n                // \"pkg\" is one single package\r\n                if (packages.endsWith(targetPkg)) {\r\n\r\n                    // \"pkg\" is the target package\r\n                    return packages + '/' + relPath;\r\n\r\n                } else {\r\n\r\n                    // Assume \"pkg\" is the target package's parent directory\r\n                    return packages + '/' + targetPkg + '/' + relPath;\r\n\r\n                }\r\n\r\n            } else if (packages instanceof Function) {\r\n\r\n                return packages(targetPkg) + '/' + relPath;\r\n\r\n            } else if (typeof packages === 'object') {\r\n\r\n                // \"pkg\" is a map of packages\r\n                if (targetPkg in packages) {\r\n\r\n                    return packages[targetPkg] + '/' + relPath;\r\n\r\n                } else {\r\n\r\n                    console.error(`URDFLoader : ${ targetPkg } not found in provided package list.`);\r\n                    return null;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Process the URDF text format\r\n        function processUrdf(data) {\r\n\r\n            let children;\r\n            if (data instanceof Document) {\r\n\r\n                children = [ ...data.children ];\r\n\r\n            } else if (data instanceof Element) {\r\n\r\n                children = [ data ];\r\n\r\n            } else {\r\n\r\n                const parser = new DOMParser();\r\n                const urdf = parser.parseFromString(data, 'text/xml');\r\n                children = [ ...urdf.children ];\r\n\r\n            }\r\n\r\n            const robotNode = children.filter(c => c.nodeName === 'robot').pop();\r\n            return processRobot(robotNode);\r\n\r\n        }\r\n\r\n        // Process the <robot> node\r\n        function processRobot(robot) {\r\n\r\n            const robotNodes = [ ...robot.children ];\r\n            const links = robotNodes.filter(c => c.nodeName.toLowerCase() === 'link');\r\n            const joints = robotNodes.filter(c => c.nodeName.toLowerCase() === 'joint');\r\n            const materials = robotNodes.filter(c => c.nodeName.toLowerCase() === 'material');\r\n            const obj = new URDFRobot();\r\n\r\n            obj.robotName = robot.getAttribute('name');\r\n            obj.urdfRobotNode = robot;\r\n\r\n            // Create the <material> map\r\n            materials.forEach(m => {\r\n\r\n                const name = m.getAttribute('name');\r\n                materialMap[name] = processMaterial(m);\r\n\r\n            });\r\n\r\n            // Create the <link> map\r\n            const visualMap = {};\r\n            const colliderMap = {};\r\n            links.forEach(l => {\r\n\r\n                const name = l.getAttribute('name');\r\n                const isRoot = robot.querySelector(`child[link=\"${ name }\"]`) === null;\r\n                linkMap[name] = processLink(l, visualMap, colliderMap, isRoot ? obj : null);\r\n\r\n            });\r\n\r\n            // Create the <joint> map\r\n            joints.forEach(j => {\r\n\r\n                const name = j.getAttribute('name');\r\n                jointMap[name] = processJoint(j);\r\n\r\n            });\r\n\r\n            obj.joints = jointMap;\r\n            obj.links = linkMap;\r\n            obj.colliders = colliderMap;\r\n            obj.visual = visualMap;\r\n\r\n            // Link up mimic joints\r\n            const jointList = Object.values(jointMap);\r\n            jointList.forEach(j => {\r\n\r\n                if (j instanceof URDFMimicJoint) {\r\n\r\n                    jointMap[j.mimicJoint].mimicJoints.push(j);\r\n\r\n                }\r\n\r\n            });\r\n\r\n            // Detect infinite loops of mimic joints\r\n            jointList.forEach(j => {\r\n\r\n                const uniqueJoints = new Set();\r\n                const iterFunction = joint => {\r\n\r\n                    if (uniqueJoints.has(joint)) {\r\n\r\n                        throw new Error('URDFLoader: Detected an infinite loop of mimic joints.');\r\n\r\n                    }\r\n\r\n                    uniqueJoints.add(joint);\r\n                    joint.mimicJoints.forEach(j => {\r\n\r\n                        iterFunction(j);\r\n\r\n                    });\r\n\r\n                };\r\n\r\n                iterFunction(j);\r\n            });\r\n\r\n            obj.frames = {\r\n                ...colliderMap,\r\n                ...visualMap,\r\n                ...linkMap,\r\n                ...jointMap,\r\n            };\r\n\r\n            return obj;\r\n\r\n        }\r\n\r\n        // Process joint nodes and parent them\r\n        function processJoint(joint) {\r\n\r\n            const children = [ ...joint.children ];\r\n            const jointType = joint.getAttribute('type');\r\n\r\n            let obj;\r\n\r\n            const mimicTag = children.find(n => n.nodeName.toLowerCase() === 'mimic');\r\n            if (mimicTag) {\r\n\r\n                obj = new URDFMimicJoint();\r\n                obj.mimicJoint = mimicTag.getAttribute('joint');\r\n                obj.multiplier = parseFloat(mimicTag.getAttribute('multiplier') || 1.0);\r\n                obj.offset = parseFloat(mimicTag.getAttribute('offset') || 0.0);\r\n\r\n            } else {\r\n\r\n                obj = new URDFJoint();\r\n\r\n            }\r\n\r\n            obj.urdfNode = joint;\r\n            obj.name = joint.getAttribute('name');\r\n            obj.urdfName = obj.name;\r\n            obj.jointType = jointType;\r\n\r\n            let parent = null;\r\n            let child = null;\r\n            let xyz = [0, 0, 0];\r\n            let rpy = [0, 0, 0];\r\n\r\n            // Extract the attributes\r\n            children.forEach(n => {\r\n\r\n                const type = n.nodeName.toLowerCase();\r\n                if (type === 'origin') {\r\n\r\n                    xyz = processTuple(n.getAttribute('xyz'));\r\n                    rpy = processTuple(n.getAttribute('rpy'));\r\n\r\n                } else if (type === 'child') {\r\n\r\n                    child = linkMap[n.getAttribute('link')];\r\n\r\n                } else if (type === 'parent') {\r\n\r\n                    parent = linkMap[n.getAttribute('link')];\r\n\r\n                } else if (type === 'limit') {\r\n\r\n                    obj.limit.lower = parseFloat(n.getAttribute('lower') || obj.limit.lower);\r\n                    obj.limit.upper = parseFloat(n.getAttribute('upper') || obj.limit.upper);\r\n\r\n                }\r\n            });\r\n\r\n            // Join the links\r\n            parent.add(obj);\r\n            obj.add(child);\r\n            applyRotation(obj, rpy);\r\n            obj.position.set(xyz[0], xyz[1], xyz[2]);\r\n\r\n            // Set up the rotate function\r\n            const axisNode = children.filter(n => n.nodeName.toLowerCase() === 'axis')[0];\r\n\r\n            if (axisNode) {\r\n\r\n                const axisXYZ = axisNode.getAttribute('xyz').split(/\\s+/g).map(num => parseFloat(num));\r\n                obj.axis = new THREE.Vector3(axisXYZ[0], axisXYZ[1], axisXYZ[2]);\r\n                obj.axis.normalize();\r\n\r\n            }\r\n\r\n            return obj;\r\n\r\n        }\r\n\r\n        // Process the <link> nodes\r\n        function processLink(link, visualMap, colliderMap, target = null) {\r\n\r\n            if (target === null) {\r\n\r\n                target = new URDFLink();\r\n\r\n            }\r\n\r\n            const children = [ ...link.children ];\r\n            target.name = link.getAttribute('name');\r\n            target.urdfName = target.name;\r\n            target.urdfNode = link;\r\n\r\n            if (parseVisual) {\r\n\r\n                const visualNodes = children.filter(n => n.nodeName.toLowerCase() === 'visual');\r\n                visualNodes.forEach(vn => {\r\n\r\n                    const v = processLinkElement(vn, materialMap);\r\n                    target.add(v);\r\n\r\n                    if (vn.hasAttribute('name')) {\r\n\r\n                        const name = vn.getAttribute('name');\r\n                        v.name = name;\r\n                        v.urdfName = name;\r\n                        visualMap[name] = v;\r\n\r\n                    }\r\n\r\n                });\r\n\r\n            }\r\n\r\n            if (parseCollision) {\r\n\r\n                const collisionNodes = children.filter(n => n.nodeName.toLowerCase() === 'collision');\r\n                collisionNodes.forEach(cn => {\r\n\r\n                    const c = processLinkElement(cn);\r\n                    target.add(c);\r\n\r\n                    if (cn.hasAttribute('name')) {\r\n\r\n                        const name = cn.getAttribute('name');\r\n                        c.name = name;\r\n                        c.urdfName = name;\r\n                        colliderMap[name] = c;\r\n\r\n                    }\r\n\r\n                });\r\n\r\n            }\r\n\r\n            return target;\r\n\r\n        }\r\n\r\n        function processMaterial(node) {\r\n\r\n            const matNodes = [ ...node.children ];\r\n            const material = new THREE.MeshPhongMaterial();\r\n\r\n            material.name = node.getAttribute('name') || '';\r\n            matNodes.forEach(n => {\r\n\r\n                const type = n.nodeName.toLowerCase();\r\n                if (type === 'color') {\r\n\r\n                    const rgba =\r\n                        n\r\n                            .getAttribute('rgba')\r\n                            .split(/\\s/g)\r\n                            .map(v => parseFloat(v));\r\n\r\n                    material.color.setRGB(rgba[0], rgba[1], rgba[2]);\r\n                    material.opacity = rgba[3];\r\n                    material.transparent = rgba[3] < 1;\r\n                    material.depthWrite = !material.transparent;\r\n\r\n                } else if (type === 'texture') {\r\n\r\n                    // The URDF spec does not require that the <texture/> tag include\r\n                    // a filename attribute so skip loading the texture if not provided.\r\n                    const filename = n.getAttribute('filename');\r\n                    if (filename) {\r\n\r\n                        const loader = new THREE.TextureLoader(manager);\r\n                        const filePath = resolvePath(filename);\r\n                        material.map = loader.load(filePath);\r\n\r\n                    }\r\n\r\n                }\r\n            });\r\n\r\n            return material;\r\n\r\n        }\r\n\r\n        // Process the visual and collision nodes into meshes\r\n        function processLinkElement(vn, materialMap = {}) {\r\n\r\n            const isCollisionNode = vn.nodeName.toLowerCase() === 'collision';\r\n            const children = [ ...vn.children ];\r\n            let material = null;\r\n\r\n            // get the material first\r\n            const materialNode = children.filter(n => n.nodeName.toLowerCase() === 'material')[0];\r\n            if (materialNode) {\r\n\r\n                const name = materialNode.getAttribute('name');\r\n                if (name && name in materialMap) {\r\n\r\n                    material = materialMap[name];\r\n\r\n                } else {\r\n\r\n                    material = processMaterial(materialNode);\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                material = new THREE.MeshPhongMaterial();\r\n\r\n            }\r\n\r\n            const group = isCollisionNode ? new URDFCollider() : new URDFVisual();\r\n            group.urdfNode = vn;\r\n\r\n            children.forEach(n => {\r\n\r\n                const type = n.nodeName.toLowerCase();\r\n                if (type === 'geometry') {\r\n\r\n                    const geoType = n.children[0].nodeName.toLowerCase();\r\n                    if (geoType === 'mesh') {\r\n\r\n                        const filename = n.children[0].getAttribute('filename');\r\n                        const filePath = resolvePath(filename);\r\n\r\n                        // file path is null if a package directory is not provided.\r\n                        if (filePath !== null) {\r\n\r\n                            const scaleAttr = n.children[0].getAttribute('scale');\r\n                            if (scaleAttr) {\r\n\r\n                                const scale = processTuple(scaleAttr);\r\n                                group.scale.set(scale[0], scale[1], scale[2]);\r\n\r\n                            }\r\n\r\n                            loadMeshCb(filePath, manager, (obj, err) => {\r\n\r\n                                if (err) {\r\n\r\n                                    console.error('URDFLoader: Error loading mesh.', err);\r\n\r\n                                } else if (obj) {\r\n\r\n                                    if (obj instanceof THREE.Mesh) {\r\n\r\n                                        obj.material = material;\r\n\r\n                                    }\r\n\r\n                                    // We don't expect non identity rotations or positions. In the case of\r\n                                    // COLLADA files the model might come in with a custom scale for unit\r\n                                    // conversion.\r\n                                    obj.position.set(0, 0, 0);\r\n                                    obj.quaternion.identity();\r\n                                    group.add(obj);\r\n\r\n                                }\r\n\r\n                            });\r\n\r\n                        }\r\n\r\n                    } else if (geoType === 'box') {\r\n\r\n                        const primitiveModel = new THREE.Mesh();\r\n                        primitiveModel.geometry = new THREE.BoxBufferGeometry(1, 1, 1);\r\n                        primitiveModel.material = material;\r\n\r\n                        const size = processTuple(n.children[0].getAttribute('size'));\r\n                        primitiveModel.scale.set(size[0], size[1], size[2]);\r\n\r\n                        group.add(primitiveModel);\r\n\r\n                    } else if (geoType === 'sphere') {\r\n\r\n                        const primitiveModel = new THREE.Mesh();\r\n                        primitiveModel.geometry = new THREE.SphereBufferGeometry(1, 30, 30);\r\n                        primitiveModel.material = material;\r\n\r\n                        const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\r\n                        primitiveModel.scale.set(radius, radius, radius);\r\n\r\n                        group.add(primitiveModel);\r\n\r\n                    } else if (geoType === 'cylinder') {\r\n\r\n                        const primitiveModel = new THREE.Mesh();\r\n                        primitiveModel.geometry = new THREE.CylinderBufferGeometry(1, 1, 1, 30);\r\n                        primitiveModel.material = material;\r\n\r\n                        const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\r\n                        const length = parseFloat(n.children[0].getAttribute('length')) || 0;\r\n                        primitiveModel.scale.set(radius, length, radius);\r\n                        primitiveModel.rotation.set(Math.PI / 2, 0, 0);\r\n\r\n                        group.add(primitiveModel);\r\n\r\n                    }\r\n\r\n                } else if (type === 'origin') {\r\n\r\n                    const xyz = processTuple(n.getAttribute('xyz'));\r\n                    const rpy = processTuple(n.getAttribute('rpy'));\r\n\r\n                    group.position.set(xyz[0], xyz[1], xyz[2]);\r\n                    group.rotation.set(0, 0, 0);\r\n                    applyRotation(group, rpy);\r\n\r\n                }\r\n\r\n            });\r\n\r\n            return group;\r\n\r\n        }\r\n\r\n        return processUrdf(content);\r\n\r\n    }\r\n\r\n    // Default mesh loading function\r\n    defaultMeshLoader(path, manager, done) {\r\n\r\n        if (/\\.stl$/i.test(path)) {\r\n\r\n            const loader = new STLLoader(manager);\r\n            loader.load(path, geom => {\r\n                const mesh = new THREE.Mesh(geom, new THREE.MeshPhongMaterial());\r\n                done(mesh);\r\n            });\r\n\r\n        } else if (/\\.dae$/i.test(path)) {\r\n\r\n            const loader = new ColladaLoader(manager);\r\n            loader.load(path, dae => done(dae.scene));\r\n\r\n        } else {\r\n\r\n            console.warn(`URDFLoader: Could not load model at ${ path }.\\nNo loader available`);\r\n\r\n        }\r\n\r\n    }\r\n\r\n};\r\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tLoaderUtils,\n\tVector3\n} from 'three';\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  const loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  const mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * const mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  const materials = [];\n *  const nGeometryGroups = geometry.groups.length;\n *\n *  const colorMap = ...; // Some logic to index colors.\n *\n *  for (let i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tconst material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  const mesh = new THREE.Mesh(geometry, materials);\n */\n\n\nclass STLLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tconst n_faces = reader.getUint32( 80, true );\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst faces = reader.getUint32( 80, true );\n\n\t\t\tlet r, g, b, hasColors = false, colors;\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst dataOffset = 84;\n\t\t\tconst faceLength = 12 * 4 + 2;\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\t\tconst start = dataOffset + face * faceLength;\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tconst vertexstart = start + i * 12;\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tlet faceCounter = 0;\n\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\n\t\t\tconst normal = new Vector3();\n\n\t\t\tlet result;\n\n\t\t\tlet groupCount = 0;\n\t\t\tlet startVertex = 0;\n\t\t\tlet endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tconst solid = result[ 0 ];\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\t\tconst text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst start = startVertex;\n\t\t\t\tconst count = endVertex - startVertex;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn LoaderUtils.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tconst binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n}\n\nexport { STLLoader };\n","import {\n\tAmbientLight,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tEuler,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tGroup,\n\tLine,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tLoaderUtils,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshLambertMaterial,\n\tMeshPhongMaterial,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tScene,\n\tSkeleton,\n\tSkinnedMesh,\n\tSpotLight,\n\tTextureLoader,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tsRGBEncoding\n} from 'three';\nimport { TGALoader } from '../loaders/TGALoader.js';\n\nclass ColladaLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tconst array = [];\n\t\t\tconst childNodes = xml.childNodes;\n\n\t\t\tfor ( let i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tconst library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tconst elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tlet hasChildren = false;\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tconst target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tlet parts = target.split( '/' );\n\n\t\t\tconst id = parts.shift();\n\t\t\tlet sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tconst arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tconst memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tconst indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst channels = data.channels;\n\t\t\tconst samplers = data.samplers;\n\t\t\tconst sources = data.sources;\n\n\t\t\tfor ( const target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tconst channel = channels[ target ];\n\t\t\t\t\tconst sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tconst inputId = sampler.inputs.INPUT;\n\t\t\t\t\tconst outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tconst inputSource = sources[ inputId ];\n\t\t\t\t\tconst outputSource = sources[ outputId ];\n\n\t\t\t\t\tconst animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tconst node = library.nodes[ channel.id ];\n\t\t\tconst object3D = getNode( node.id );\n\n\t\t\tconst transform = node.transforms[ channel.sid ];\n\t\t\tconst defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tlet time, stride;\n\t\t\tlet i, il, j, jl;\n\n\t\t\tconst data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tconst value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tconst index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tconst animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tconst keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( const time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst position = new Vector3();\n\t\tconst scale = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tconst keyframes = animation.keyframes;\n\t\t\tconst name = animation.name;\n\n\t\t\tconst times = [];\n\t\t\tconst positionData = [];\n\t\t\tconst quaternionData = [];\n\t\t\tconst scaleData = [];\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tconst time = keyframe.time;\n\t\t\t\tconst value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tlet keyframe;\n\n\t\t\tlet empty = true;\n\t\t\tlet i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tlet prev, next;\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst name = data.name;\n\t\t\tconst duration = ( data.end - data.start ) || - 1;\n\t\t\tconst animations = data.animations;\n\n\t\t\tfor ( let i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tconst animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tconst id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tconst build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tconst geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tconst BONE_LIMIT = 4;\n\n\t\t\tconst build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertexWeights = data.vertexWeights;\n\n\t\t\tconst vcount = vertexWeights.vcount;\n\t\t\tconst v = vertexWeights.v;\n\t\t\tconst jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tconst weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tconst jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tconst inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tconst weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tlet stride = 0;\n\n\t\t\tlet i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tconst jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tconst vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tconst skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tconst weightId = v[ stride + weightOffset ];\n\t\t\t\t\tconst skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tconst d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = jointSource.array[ i ];\n\t\t\t\tconst boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tconst data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tconst sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE',\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechniqueBump( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tlet loader;\n\n\t\t\tlet extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst effect = getEffect( data.url );\n\t\t\tconst technique = effect.profile.technique;\n\n\t\t\tlet material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject, encoding = null ) {\n\n\t\t\t\tconst sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tlet image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tconst surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tconst loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tconst texture = loader.load( image );\n\n\t\t\t\t\t\tconst extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tconst technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( encoding !== null ) {\n\n\t\t\t\t\t\t\ttexture.encoding = encoding;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst parameters = technique.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tconst parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture, sRGBEncoding );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture, sRGBEncoding );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture, sRGBEncoding );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial.color.convertSRGBToLinear();\n\t\t\tif ( material.specular ) material.specular.convertSRGBToLinear();\n\t\t\tif ( material.emissive ) material.emissive.convertSRGBToLinear();\n\n\t\t\t//\n\n\t\t\tlet transparent = parameters[ 'transparent' ];\n\t\t\tlet transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\n\t\t\tif ( technique.extra !== undefined && technique.extra.technique !== undefined ) {\n\n\t\t\t\tconst techniques = technique.extra.technique;\n\n\t\t\t\tfor ( const k in techniques ) {\n\n\t\t\t\t\tconst v = techniques[ k ];\n\n\t\t\t\t\tswitch ( k ) {\n\n\t\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\t\tmaterial.side = ( v === 1 ? DoubleSide : FrontSide );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\t\tmaterial.normalMap = getTexture( v.texture );\n\t\t\t\t\t\t\tmaterial.normalScale = new Vector2( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tlet camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new PerspectiveCamera(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tlet ymag = data.optics.parameters.ymag;\n\t\t\t\t\tlet xmag = data.optics.parameters.xmag;\n\t\t\t\t\tconst aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new OrthographicCamera(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tconst data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tlet data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new Color().fromArray( array ).convertSRGBToLinear();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tconst f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tlet light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tconst data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tconst mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( let i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tconst id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tconst accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tconst primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tconst set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tconst inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tconst build = {};\n\n\t\t\tfor ( let i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tlet count = 0;\n\n\t\t\tfor ( let i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertices = data.vertices;\n\t\t\tconst primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tconst groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( const type in groupedPrimitives ) {\n\n\t\t\t\tconst primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst position = { array: [], stride: 0 };\n\t\t\tconst normal = { array: [], stride: 0 };\n\t\t\tconst uv = { array: [], stride: 0 };\n\t\t\tconst uv2 = { array: [], stride: 0 };\n\t\t\tconst color = { array: [], stride: 0 };\n\n\t\t\tconst skinIndex = { array: [], stride: 4 };\n\t\t\tconst skinWeight = { array: [], stride: 4 };\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst materialKeys = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tconst primitive = primitives[ p ];\n\t\t\t\tconst inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tlet count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( let g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tconst vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( const name in inputs ) {\n\n\t\t\t\t\tconst input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( const key in vertices ) {\n\n\t\t\t\t\t\t\t\tconst id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tconst prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array, true );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array, isColor = false ) {\n\n\t\t\tconst indices = primitive.p;\n\t\t\tconst stride = primitive.stride;\n\t\t\tconst vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tlet index = indices[ i + offset ] * sourceStride;\n\t\t\t\tconst length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isColor ) {\n\n\t\t\t\t\t// convert the vertex colors from srgb to linear if present\n\t\t\t\t\tconst startIndex = array.length - sourceStride - 1;\n\t\t\t\t\ttempColor.setRGB(\n\t\t\t\t\t\tarray[ startIndex + 0 ],\n\t\t\t\t\t\tarray[ startIndex + 1 ],\n\t\t\t\t\t\tarray[ startIndex + 2 ]\n\t\t\t\t\t).convertSRGBToLinear();\n\n\t\t\t\t\tarray[ startIndex + 0 ] = tempColor.r;\n\t\t\t\t\tarray[ startIndex + 1 ] = tempColor.g;\n\t\t\t\t\tarray[ startIndex + 2 ] = tempColor.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst sourceArray = source.array;\n\t\t\tconst sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor ( let i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\t\t\t\t\t\tconst d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\t\tconst b = index + stride * k;\n\t\t\t\t\t\t\tconst c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tlet data;\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tconst max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tconst min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tconst array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new Matrix4();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tconst tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substring( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tconst kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tconst kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tconst visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tconst kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tconst kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tconst visualScene = getVisualScene( visualSceneId );\n\n\t\t\tconst bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tconst jointMap = {};\n\n\t\t\tfor ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tconst axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tconst targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tconst parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tconst visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tconst joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst m0 = new Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tconst joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst object = jointData.object;\n\t\t\t\t\t\t\tconst axis = joint.axis;\n\t\t\t\t\t\t\tconst transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tconst transforms = [];\n\n\t\t\tconst xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array, vector;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst matrix = new Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tconst elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst matrix = new Matrix4();\n\t\tconst vector = new Vector3();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tconst instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( let j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\tconst symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tconst target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tconst boneData = [];\n\t\t\tconst sortedBoneData = [];\n\n\t\t\tlet i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tconst skeleton = skeletons[ i ];\n\n\t\t\t\tlet root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tconst visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tconst children = visualScene.children;\n\n\t\t\t\t\tfor ( let j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tconst child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tconst root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tlet boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( let i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tconst joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tconst matrix = data.matrix;\n\t\t\tconst nodes = data.nodes;\n\t\t\tconst type = data.type;\n\t\t\tconst instanceCameras = data.instanceCameras;\n\t\t\tconst instanceControllers = data.instanceControllers;\n\t\t\tconst instanceLights = data.instanceLights;\n\t\t\tconst instanceGeometries = data.instanceGeometries;\n\t\t\tconst instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceControllers[ i ];\n\t\t\t\tconst controller = getController( instance.id );\n\t\t\t\tconst geometries = getGeometry( controller.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tconst skeletons = instance.skeletons;\n\t\t\t\tconst joints = controller.skin.joints;\n\n\t\t\t\tconst skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( let i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tconst geometries = getGeometry( instance.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tlet object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new Bone() : new Group();\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tconst fallbackMaterial = new MeshBasicMaterial( { color: 0xff00ff } );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tconst materials = [];\n\n\t\t\tfor ( let i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tconst id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tfor ( const type in geometries ) {\n\n\t\t\t\tconst geometry = geometries[ type ];\n\n\t\t\t\tconst materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new LineBasicMaterial() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new MeshPhongMaterial() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tconst skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tconst material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tlet object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new LineSegments( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new Line( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tconst elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tconst instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tconst clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tconst tracks = [];\n\n\t\t\t\t\tfor ( const id in library.animations ) {\n\n\t\t\t\t\t\tconst animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( let i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( const id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tlet result = '';\n\t\t\tconst stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tconst node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new Scene() };\n\n\t\t}\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tconst collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tconst parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tconst errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tlet errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tconst version = collada.getAttribute( 'version' );\n\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\tconst asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tconst textureLoader = new TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tlet tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tconst tempColor = new Color();\n\t\tconst animations = [];\n\t\tlet kinematics = {};\n\t\tlet count = 0;\n\n\t\t//\n\n\t\tconst library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tconst scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tscene.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n}\n\nexport { ColladaLoader };\n","import {\n\tDataTextureLoader,\n\tLinearMipmapLinearFilter\n} from 'three';\n\nclass TGALoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tlet pixel_data,\n\t\t\t\tpalettes;\n\n\t\t\tconst pixel_size = header.pixel_size >> 3;\n\t\t\tconst pixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tlet c, count, i;\n\t\t\t\tlet shift = 0;\n\t\t\t\tconst pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tconst colormap = palettes;\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 );\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) << 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tlet x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tconst TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tlet offset = 0;\n\n\t\tconst content = new Uint8Array( buffer ),\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tlet use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tconst imageData = new Uint8Array( header.width * header.height * 4 );\n\t\tconst result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\treturn {\n\n\t\t\tdata: imageData,\n\t\t\twidth: header.width,\n\t\t\theight: header.height,\n\t\t\tflipY: true,\n\t\t\tgenerateMipmaps: true,\n\t\t\tminFilter: LinearMipmapLinearFilter,\n\n\t\t};\n\n\t}\n\n}\n\nexport { TGALoader };\n","import { Object3D } from 'three';\r\n\r\nclass URDFBase extends Object3D {\r\n\r\n    constructor(...args) {\r\n\r\n        super(...args);\r\n        this.urdfNode = null;\r\n        this.urdfName = '';\r\n\r\n    }\r\n\r\n    copy(source, recursive) {\r\n\r\n        super.copy(source, recursive);\r\n\r\n        this.urdfNode = source.urdfNode;\r\n        this.urdfName = source.urdfName;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n}\r\n\r\nclass URDFCollider extends URDFBase {\r\n\r\n    constructor(...args) {\r\n\r\n        super(...args);\r\n        this.isURDFCollider = true;\r\n        this.type = 'URDFCollider';\r\n\r\n    }\r\n\r\n}\r\n\r\nclass URDFVisual extends URDFBase {\r\n\r\n    constructor(...args) {\r\n\r\n        super(...args);\r\n        this.isURDFVisual = true;\r\n        this.type = 'URDFVisual';\r\n\r\n    }\r\n\r\n}\r\n\r\nclass URDFLink extends URDFBase {\r\n\r\n    constructor(...args) {\r\n\r\n        super(...args);\r\n        this.isURDFLink = true;\r\n        this.type = 'URDFLink';\r\n\r\n    }\r\n\r\n}\r\n\r\nclass URDFJoint extends URDFBase {\r\n\r\n    get jointType() {\r\n\r\n        return this._jointType;\r\n\r\n    }\r\n\r\n    set jointType(v) {\r\n\r\n        if (this.jointType === v) return;\r\n        this._jointType = v;\r\n        this.matrixWorldNeedsUpdate = true;\r\n        switch (v) {\r\n\r\n            case 'fixed':\r\n                this.jointValue = [];\r\n                break;\r\n\r\n            case 'continuous':\r\n            case 'revolute':\r\n            case 'prismatic':\r\n                this.jointValue = new Array(1).fill(0);\r\n                break;\r\n\r\n            case 'planar':\r\n                this.jointValue = new Array(2).fill(0);\r\n                break;\r\n\r\n            case 'floating':\r\n                this.jointValue = new Array(6).fill(0);\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    get angle() {\r\n\r\n        return this.jointValue[0];\r\n\r\n    }\r\n\r\n    constructor(...args) {\r\n\r\n        super(...args);\r\n\r\n        this.isURDFJoint = true;\r\n        this.type = 'URDFJoint';\r\n\r\n        this.jointValue = null;\r\n        this.jointType = 'fixed';\r\n        this.axis = null;\r\n        this.limit = { lower: 0, upper: 0 };\r\n        this.ignoreLimits = false;\r\n\r\n        this.origPosition = null;\r\n        this.origQuaternion = null;\r\n\r\n        this.mimicJoints = [];\r\n\r\n    }\r\n\r\n    /* Overrides */\r\n    copy(source, recursive) {\r\n\r\n        super.copy(source, recursive);\r\n\r\n        this.jointType = source.jointType;\r\n        this.axis = source.axis ? source.axis.clone() : null;\r\n        this.limit.lower = source.limit.lower;\r\n        this.limit.upper = source.limit.upper;\r\n        this.ignoreLimits = false;\r\n\r\n        this.jointValue = [...source.jointValue];\r\n\r\n        this.origPosition = source.origPosition ? source.origPosition.clone() : null;\r\n        this.origQuaternion = source.origQuaternion ? source.origQuaternion.clone() : null;\r\n\r\n        this.mimicJoints = [...source.mimicJoints];\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /* Public Functions */\r\n    setJointValue(...values) {\r\n\r\n        values = values.map(v => parseFloat(v));\r\n\r\n        if (!this.origPosition || !this.origQuaternion) {\r\n\r\n            this.origPosition = this.position.clone();\r\n            this.origQuaternion = this.quaternion.clone();\r\n\r\n        }\r\n\r\n        let didUpdate = false;\r\n\r\n        this.mimicJoints.forEach(joint => {\r\n\r\n            didUpdate = joint.updateFromMimickedJoint(...values) || didUpdate;\r\n\r\n        });\r\n\r\n        switch (this.jointType) {\r\n\r\n            case 'fixed': {\r\n\r\n                return didUpdate;\r\n\r\n            }\r\n            case 'continuous':\r\n            case 'revolute': {\r\n\r\n                let angle = values[0];\r\n                if (angle == null) return didUpdate;\r\n                if (angle === this.jointValue[0]) return didUpdate;\r\n\r\n                if (!this.ignoreLimits && this.jointType === 'revolute') {\r\n\r\n                    angle = Math.min(this.limit.upper, angle);\r\n                    angle = Math.max(this.limit.lower, angle);\r\n\r\n                }\r\n\r\n                this.quaternion\r\n                    .setFromAxisAngle(this.axis, angle)\r\n                    .premultiply(this.origQuaternion);\r\n\r\n                if (this.jointValue[0] !== angle) {\r\n\r\n                    this.jointValue[0] = angle;\r\n                    this.matrixWorldNeedsUpdate = true;\r\n                    return true;\r\n\r\n                } else {\r\n\r\n                    return didUpdate;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            case 'prismatic': {\r\n\r\n                let pos = values[0];\r\n                if (pos == null) return didUpdate;\r\n                if (pos === this.jointValue[0]) return didUpdate;\r\n\r\n                if (!this.ignoreLimits) {\r\n\r\n                    pos = Math.min(this.limit.upper, pos);\r\n                    pos = Math.max(this.limit.lower, pos);\r\n\r\n                }\r\n\r\n                this.position.copy(this.origPosition);\r\n                this.position.addScaledVector(this.axis, pos);\r\n\r\n                if (this.jointValue[0] !== pos) {\r\n\r\n                    this.jointValue[0] = pos;\r\n                    this.matrixWorldNeedsUpdate = true;\r\n                    return true;\r\n\r\n                } else {\r\n\r\n                    return didUpdate;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            case 'floating':\r\n            case 'planar':\r\n                // TODO: Support these joint types\r\n                console.warn(`'${ this.jointType }' joint not yet supported`);\r\n\r\n        }\r\n\r\n        return didUpdate;\r\n\r\n    }\r\n\r\n}\r\n\r\nclass URDFMimicJoint extends URDFJoint {\r\n\r\n    constructor(...args) {\r\n\r\n        super(...args);\r\n        this.type = 'URDFMimicJoint';\r\n        this.mimicJoint = null;\r\n        this.offset = 0;\r\n        this.multiplier = 1;\r\n\r\n    }\r\n\r\n    updateFromMimickedJoint(...values) {\r\n\r\n        const modifiedValues = values.map(x => x * this.multiplier + this.offset);\r\n        return super.setJointValue(...modifiedValues);\r\n\r\n    }\r\n\r\n    /* Overrides */\r\n    setJointValue(...values) {\r\n\r\n        console.warn(`URDFMimicJoint: Setting the joint value of mimic joint \"${ this.urdfName }\" will cause it to be out of sync.`);\r\n        return super.setJointValue(...values);\r\n    }\r\n\r\n    /* Overrides */\r\n    copy(source, recursive) {\r\n\r\n        super.copy(source, recursive);\r\n\r\n        this.mimicJoint = source.mimicJoint;\r\n        this.offset = source.offset;\r\n        this.multiplier = source.multiplier;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n}\r\n\r\nclass URDFRobot extends URDFLink {\r\n\r\n    constructor(...args) {\r\n\r\n        super(...args);\r\n        this.isURDFRobot = true;\r\n        this.urdfNode = null;\r\n\r\n        this.urdfRobotNode = null;\r\n        this.robotName = null;\r\n\r\n        this.links = null;\r\n        this.joints = null;\r\n        this.colliders = null;\r\n        this.visual = null;\r\n        this.frames = null;\r\n\r\n    }\r\n\r\n    copy(source, recursive) {\r\n\r\n        super.copy(source, recursive);\r\n\r\n        this.urdfRobotNode = source.urdfRobotNode;\r\n        this.robotName = source.robotName;\r\n\r\n        this.links = {};\r\n        this.joints = {};\r\n        this.colliders = {};\r\n        this.visual = {};\r\n\r\n        this.traverse(c => {\r\n\r\n            if (c.isURDFJoint && c.urdfName in source.joints) {\r\n\r\n                this.joints[c.urdfName] = c;\r\n\r\n            }\r\n\r\n            if (c.isURDFLink && c.urdfName in source.links) {\r\n\r\n                this.links[c.urdfName] = c;\r\n\r\n            }\r\n\r\n            if (c.isURDFCollider && c.urdfName in source.colliders) {\r\n\r\n                this.colliders[c.urdfName] = c;\r\n\r\n            }\r\n\r\n            if (c.isURDFVisual && c.urdfName in source.visual) {\r\n\r\n                this.visual[c.urdfName] = c;\r\n\r\n            }\r\n\r\n        });\r\n\r\n        this.frames = {\r\n            ...this.colliders,\r\n            ...this.visual,\r\n            ...this.links,\r\n            ...this.joints,\r\n        };\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    getFrame(name) {\r\n\r\n        return this.frames[name];\r\n\r\n    }\r\n\r\n    setJointValue(jointName, ...angle) {\r\n\r\n        const joint = this.joints[jointName];\r\n        if (joint) {\r\n\r\n            return joint.setJointValue(...angle);\r\n\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    setJointValues(values) {\r\n\r\n        let didChange = false;\r\n        for (const name in values) {\r\n\r\n            const value = values[name];\r\n            if (Array.isArray(value)) {\r\n\r\n                didChange = this.setJointValue(name, ...value) || didChange;\r\n\r\n            } else {\r\n\r\n                didChange = this.setJointValue(name, value) || didChange;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return didChange;\r\n\r\n    }\r\n\r\n}\r\n\r\nexport { URDFRobot, URDFLink, URDFJoint, URDFMimicJoint, URDFVisual, URDFCollider };\r\n"],"names":["$6452ad36f92729a4$var$tempQuaternion","$ilwiq","Quaternion","$6452ad36f92729a4$var$tempEuler","Euler","val","trim","split","map","num","parseFloat","$6452ad36f92729a4$var$applyRotation","obj","rpy","additive","rotation","set","setFromEuler","multiply","quaternion","copy","manager","this","DefaultLoadingManager","loadMeshCb","defaultMeshLoader","bind","parseVisual","parseCollision","packages","loadAsync","urdf","Promise","resolve","reject","load","onComplete","onProgress","onError","workingPath","LoaderUtils","extractUrlBase","urdfPath","resolveURL","itemStart","fetch","fetchOptions","then","res","ok","text","Error","status","statusText","data","model","parse","itemEnd","catch","e","console","error","itemError","resolvePath","path","test","targetPkg","relPath","replace","endsWith","Function","node","children","material","MeshPhongMaterial","name","getAttribute","matNodes","forEach","n","type","nodeName","toLowerCase","rgba","v","color","setRGB","opacity","transparent","depthWrite","filename","loader","TextureLoader","filePath","vn","materialMap","filter","materialNode","$3iDF4","URDFCollider","URDFVisual","scaleAttr","scale","$6452ad36f92729a4$var$processTuple","group","err","Mesh","position","identity","add","geoType","primitiveModel","geometry","BoxBufferGeometry","size","SphereBufferGeometry","radius","CylinderBufferGeometry","length","Math","PI","xyz","Document","parseFromString","robot","robotNodes","links","c","joints","materials","URDFRobot","robotName","urdfRobotNode","m","materialMap1","processMaterial","visualMap","colliderMap","l","isRoot","querySelector","link","target","URDFLink","processLinkElement","hasAttribute","urdfName","cn","processLink","j","jointMap","joint","jointType","mimicTag","find","URDFMimicJoint","mimicJoint","multiplier","offset","URDFJoint","child","linkMap","parent","limit","lower","upper","axisNode","axisXYZ","axis","Vector3","normalize","processJoint","Object","values","jointList","mimicJoints","push","j1","uniqueJoints","Set","iterFunction","has","frames","processRobot","$09c9a4300c0632b1$export$78deb5981b3aff86","Loader","super","url","onLoad","scope","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data1","matchDataViewAt","query","reader","i","il","getUint8","binData","buffer","array_buffer","Uint8Array","charCodeAt","ensureBinary","DataView","getUint32","byteLength","solid","off","isBinary","faces","r","g","b","colors","defaultR","defaultG","defaultB","alpha","hasColors","index","Float32Array","BufferGeometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setAttribute","BufferAttribute","parseBinary","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","normal","result","groupCount","startVertex","endVertex","exec","vertexCountPerFace","normalCountPerFace","x","y","z","count","addGroup","Float32BufferAttribute","parseASCII","decodeText","$7f99d0845977052a$export$ce4e0fe932362815","text1","getElementsByTagName","xml","array","childNodes","parseStrings","parts","Array","parseFloats","parseInts","parseInt","parseId","substring","isEmpty","object","keys","parseAssetUnit","undefined","parseAssetUpAxis","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","builder","build","getBuild","parseAnimationSampler","inputs","nodeType","id","semantic","parseAnimationChannel","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","sampler","buildAnimation","tracks","channels","samplers","sources","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","createKeyframeTracks","buildAnimationChannel","getAnimation","library1","animations","inputSource","outputSource","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","jl","value","warn","keyframes","sort","ascending","transformAnimationData","a","prepareAnimationData","uuid","position1","animation","times","positionData","quaternionData","scaleData","keyframe","matrix1","fromArray","decompose","w","VectorKeyframeTrack","QuaternionKeyframeTrack","property","defaultValue","empty","prev","next","getPrev","getNext","interpolate","createMissingKeyframes","key","buildAnimationClip","duration","end","animationTracks","AnimationClip","getAnimationClip","clips","parseSkin","bindShapeMatrix","parseSource","parseJoints","vertexWeights","parseVertexWeights","vcount","buildController","geometries","skin","BONE_LIMIT","weights","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","skinWeight","weight","descending","d","bindMatrix","Matrix4","boneInverse","buildSkin","skinIndices","skinWeights","buildImage","init_from","getImage","images","parseEffectProfileCOMMON","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","buildMaterial","effect","effects","technique1","profile","MeshLambertMaterial","MeshBasicMaterial","getTexture","textureObject","encoding","image","extension","slice","lastIndexOf","tgaLoader","textureLoader","getTextureLoader","texture","wrapS","wrapU","RepeatWrapping","ClampToEdgeWrapping","wrapT","wrapV","offsetU","offsetV","repeat","repeatU","repeatV","parameter","sRGBEncoding","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","convertSRGBToLinear","transparency","techniques","k","side","DoubleSide","FrontSide","normalScale","Vector2","getMaterial","parseCameraOptics","parseCameraTechnique","parseCameraParameters","buildCamera","camera","optics","PerspectiveCamera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","OrthographicCamera","getCamera","cameras","parseLightTechnique","parseLightParameters","Color","falloffAngle","f","distance","sqrt","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","getLight","lights","accessor","parseGeometryVertices","parseGeometryPrimitive","primitive","hasUV","inputname","max","p","checkUVCoordinates","primitives","uvsNeedsFix","buildGeometry","groupedPrimitives","groupPrimitives","primitiveType","buildGeometryType","uv","uv2","materialKeys","vc","input","prevLength","buildGeometryData","isColor","pushVector","sourceStride","sourceArray","startIndex","tempColor","kl","getGeometry","buildKinematicsModel","parseKinematicsTechniqueCommon","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","pop","angle","MathUtils","degToRad","parsePhysicsRigidBody","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsBindJointAxis","param","tmpJointIndex","jointIndex","buildKinematicsScene","buildTransformList","collada","vector","vector1","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","makeTranslation","makeRotationAxis","log","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","visualScenes","bone","processed","bones","boneInverses","Skeleton","traverse","isBone","buildNode","objects","i2","l1","instanceCamera","i3","l2","controller","controllers","newObjects","buildObjects","isSkinnedMesh","normalizeSkinWeights","i4","l3","instanceLight","i5","l4","i6","l5","Bone","Group","fallbackMaterial","resolveMaterialBinding","instanceMaterials","LineBasicMaterial","skinning","attributes","LineSegments","Line","SkinnedMesh","buildVisualScene","getVisualScene","scene","Scene","xml1","DOMParser","parserError1","errorElement","errorText","parserError","stack","Node","TEXT_NODE","apply","parserErrorToText","version","asset","unit","upAxis","resourcePath","setCrossOrigin","crossOrigin","$iVtfO","TGALoader","animations1","kinematics","count1","kinematicsModels","physicsModels","kinematicsScenes","parseAnimation","hasChildren","generateUUID","mesh","element","prepareNodes","rigidBodies","bindJointAxis","setupAnimations","kinematicsModelId","kinematicsSceneId","visualSceneId","kinematicsModel","kinematicsScene","getKinematicsScene","visualScene","i1","targetElement","parentVisualElement","parentElement","connect","visualElement","visualElementName","m0","getJointValue","jointData","setJointValue","setupKinematics","parseScene","multiplyScalar","$dc743e2081fd10a7$export$f133a99b4c3153a","DataTextureLoader","TGA_TYPE_NO_DATA","TGA_TYPE_INDEXED","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_INDEXED","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_BL","TGA_ORIGIN_BR","TGA_ORIGIN_UL","TGA_ORIGIN_UR","offset1","content","header1","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","width","height","pixel_size","flags","header","tgaCheckHeader","use_rle1","use_pal1","use_grey","imageData1","use_rle","use_pal","pixel_data","palettes","pixel_total","subarray","pixels","tgaParse","palette","x_start","y_start","x_step","y_step","x_end","y_end","imageData","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","colormap","tgaGetImageData8bits","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","getTgaRGBA","flipY","generateMipmaps","minFilter","LinearMipmapLinearFilter","$2671d175603a2bfb$var$URDFBase","Object3D","args","urdfNode","recursive","$2671d175603a2bfb$export$96148412cb4c79c1","isURDFCollider","$2671d175603a2bfb$export$344798c61faaed1d","isURDFVisual","$2671d175603a2bfb$export$57ce561fd28b62ce","isURDFLink","$2671d175603a2bfb$export$f821a5e904506851","_jointType","matrixWorldNeedsUpdate","jointValue","fill","isURDFJoint","ignoreLimits","origPosition","origQuaternion","didUpdate","updateFromMimickedJoint","setFromAxisAngle","premultiply","pos","addScaledVector","$2671d175603a2bfb$export$d1c279877ffff143","modifiedValues","$2671d175603a2bfb$export$3b6eeb5211e1c44","isURDFRobot","colliders","visual","getFrame","jointName","setJointValues","didChange","isArray"],"version":3,"file":"hexapod.6729373c.js.map"}